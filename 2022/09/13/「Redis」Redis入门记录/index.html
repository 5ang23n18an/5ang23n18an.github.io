<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="twq"><title>「Redis」Redis入门记录 | TwQ 的博客</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.jpg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.ttwwq.top",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/favicon.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"保持热爱，保持记录 :D"},scroll:{progress_bar:{enable:!0},percent:{enable:!1}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"mac"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">TwQ 的博客</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页 🏠</a></li><li class="menu-item"><a href="/archives">归档 📄</a></li><li class="menu-item"><a href="/tags">标签 🏷️</a></li><li class="menu-item"><a href="/todo">待办 ✅</a></li><li class="menu-item"><a href="/board">留言板 💬</a></li><li class="menu-item"><a href="/about">关于 🥳</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页 🏠</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档 📄</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签 🏷️</a></li><li class="drawer-menu-item flex-center"><a href="/todo">待办 ✅</a></li><li class="drawer-menu-item flex-center"><a href="/board">留言板 💬</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于 🥳</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">「Redis」Redis入门记录</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">twq</span> <span class="author-label">Lv.4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-09-13 19:04:23</span> <span class="mobile">2022-09-13 19:04</span> </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>&nbsp;</li><li>| <a href="/tags/Redis/">Redis</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>8 分钟</span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis是一种特殊的数据库，它的特殊之处在于，<strong>数据是存储在内存中</strong>而非磁盘上的。所以，它的读写速度相较于传统的数据库（如MySQL）会快很多，因此被广泛应用于作为<strong>缓存</strong>。</p><p>此外，Redis在项目应用中，还可以用来作为<strong>分布式锁</strong>。</p><br><h1 id="为什么要用Redis？"><a href="#为什么要用Redis？" class="headerlink" title="为什么要用Redis？"></a>为什么要用Redis？</h1><p>回答这个问题，主要就是回答：<strong>我们为什么需要缓存？</strong></p><ol><li><p>高性能：</p><p>假设某个用户第一次访问数据库中的某些数据。读取的过程会比较慢，因为它是从磁盘上读取的。</p><p>我们可以对这个过程进行一次<strong>优化</strong>：当用户第一次读取了某个数据后，将这个数据<strong>缓存在内存中</strong>。这样，当他下次再访问这个内容的时候，就可以直接从内存中快速读取了，不必再去从磁盘上找了。</p><p><strong>但是，每当数据库中的内容发生了改变之后，需要同步更新内存中的数据！</strong>这里就牵涉到了另一个问题：**<a href="/2022/09/13/%E3%80%8CRedis%E3%80%8D%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">如何保证缓存与数据库的数据一致性？</a>**</p></li><li><p>高并发：</p><p>当你的项目服务是一个高并发的场景时，<strong>分担请求压力</strong>就显得十分重要了。如果瞬时的大流量全部都来访问数据库，那么可能会直接让整个数据库服务宕机。</p><p>因此，如果我们能有缓存的话，就可以分担相当一部分的请求。</p><p>这里引出了另外三个问题：<a href="/2022/09/13/%E3%80%8CRedis%E3%80%8D%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98">缓存雪崩、穿透、击穿问题</a>。</p></li></ol><br><h1 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h1><p>在写线上项目的代码的时候，遇到过比较“神奇”的现象：明明之前写进Redis里的数据，怎么现在丢了不见了？</p><p>当时觉得奇怪，现在想想反而觉得奇怪才是奇怪！Redis是缓存，不是用来当存储的！Redis主要是基于内存来进行高性能、高并发的读写操作的。</p><p>既然内存是有限的，比如 Redis 就只能用 10G，你要是往里面写了 20G 的数据，会咋办？当然会干掉 10G 的数据，然后就保留 10G 的数据了。那干掉哪些数据，保留哪些数据？这就涉及到<strong>Redis的过期策略</strong>了。</p><p><strong>Redis的过期策略是：定期检查删除+惰性删除。</strong></p><ul><li><p>所谓「定期检查删除」，是指：<strong>Redis会在每隔一段时间（默认是100ms）随机抽取一些设置了过期时间的key，检查它们是否已经过期，如果过期就删除。</strong></p><p>至于为什么是随机抽取而不是全部扫描，是为了平衡开销而考虑的。假设Redis里面有10w个设置了过期时间的key，然后每隔100ms就要全部扫描10w个key，那Redis基本上就没法玩了，CPU资源全用来检查是否过期了。</p></li><li><p>所谓「惰性删除」，是指：<strong>在实际使用到某个key的时候，Redis会先检查一下这个key是否已经过期</strong>，如果过期就删除，然后返回null作为获取结果。</p></li></ul><p>虽然有了这样的过期机制，但其实还是有问题的：「定期检查删除」是有可能漏掉很多已经明明过期了的key，如果这些key很长一段时间内没有被查询（没有进行惰性删除），那么就会有大量的过期key堆积在Redis里，占据着大量内存。久而久之如果Redis的内存满了，这时候再要写入一个新的key该怎么办？这就涉及到了<strong>内存淘汰机制</strong>。</p><p>Redis有6种内存淘汰机制：</p><ul><li>noeviction： 当内存不足以容纳新写入数据时，新写入操作会<strong>报错</strong>。（这个一般没人用吧，实在是太恶心了）</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除<strong>最近最少使用</strong>的 key。（<strong>这个是最常用的</strong>）</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，<strong>随机</strong>移除某个 key。（这个很少用，除非有什么特殊场景需要随机？）</li><li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除<strong>最近最少使用</strong>的 key。（这个一般不太合适）</li><li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机</strong>移除某个 key。（也很少用，干啥要随机呢？）</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除<strong>过期时间最早</strong>的 key。</li></ul><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>前面说了，最常用的内存淘汰机制是allkeys-lru，即LRU(Least Recently Used)算法，也就是说 LRU 算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好 LRU 算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。</p><p><img lazyload src="/images/loading.svg" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/lru.png" alt="img"></p><p>现在面试是越来越卷了，据说某些公司考察候选者的算法题，其中就会让他手写一个LRU算法 :(</p><p>先不说纯手写从底层写一个LRU结构，我们看看如何<strong>利用JDK官方自带的数据结构来实现一个LRU</strong>？</p><p><img lazyload src="/images/loading.svg" data-src="https://doocs.github.io/advanced-java/docs/high-concurrency/images/lru-cache.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果map中的数据量大于设定的最大容量，返回true，再新加入对象时删除最旧的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest 最老的数据项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true则移除最老的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，自动移除最旧的数据</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>最后，再看看如何手写一个LRU？其实LeetCode上面就有一道这样的题：<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">LRU 缓存<i class="fas fa-external-link-alt"></i></a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DualListNode dummyHead, dummyTail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DualListNode&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="title class_">DualListNode</span>();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> <span class="title class_">DualListNode</span>();</span><br><span class="line">        dummyHead.next = dummyTail;</span><br><span class="line">        dummyTail.prev = dummyHead;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DualListNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前数据作为最近被使用过的，将它在链表中的位置更新至头部</span></span><br><span class="line">        update(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DualListNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">            update(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存容量已达上限。需要先删除最久未使用的数据，然后才能插入当前数据</span></span><br><span class="line">        <span class="keyword">if</span> (cache.size() == capacity) &#123;</span><br><span class="line">            cache.remove(pollLast());</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">DualListNode</span>(key, value);</span><br><span class="line">        <span class="comment">// 当前数据作为最新插入的，直接插在链表头部</span></span><br><span class="line">        offerFirst(node);</span><br><span class="line">        cache.put(key, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DualListNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一步：删除该节点在链表中的位置</span></span><br><span class="line">        remove(node);</span><br><span class="line">        <span class="comment">// 第二步：将该节点添加在头部</span></span><br><span class="line">        offerFirst(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">offerFirst</span><span class="params">(DualListNode node)</span> &#123;</span><br><span class="line">        node.prev = dummyHead;</span><br><span class="line">        node.next = dummyHead.next;</span><br><span class="line">        dummyHead.next.prev = node;</span><br><span class="line">        dummyHead.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(DualListNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DualListNode</span> <span class="variable">node</span> <span class="operator">=</span> dummyTail.prev;</span><br><span class="line">        remove(node);</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DualListNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key, val;</span><br><span class="line">        <span class="keyword">private</span> DualListNode prev, next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DualListNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DualListNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="Redis的线程模型？"><a href="#Redis的线程模型？" class="headerlink" title="Redis的线程模型？"></a>Redis的线程模型？</h1><p>Redis内部使用的是一个叫做 <code>FileEventHandler</code> 的处理器。这个处理器是单线程工作的，所以Redis实质上是一个单线程的模型！</p><p>它采用的是<strong>IO多路复用</strong>的机制，可以同时监听多个socket，并根据socket上的事件，来选择对应的handler进行处理。</p><p>总得来说，虽然同时会有多个socket，会并发进行不同的操作，但是IO多路复用机制会监听这些socket，并把socket产生的事件放入到队列中进行排队。然后由事件分派器从队列中取出一个个事件，把它交给对应的handler去做处理。</p><p>这个IO多路复用的具体实现思路，在我学习Netty的时候是有所了解的。可以移步至我之前的Netty学习记录：<a href="/2022/07/17/%E3%80%8CNetty%E3%80%8D%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%81%AE%E7%8E%8B%EF%BC%81">「Netty」网络编程の王！</a></p><br><h1 id="Redis支持的数据结构及其操作命令"><a href="#Redis支持的数据结构及其操作命令" class="headerlink" title="Redis支持的数据结构及其操作命令"></a>Redis支持的数据结构及其操作命令</h1><p>🔗 <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64830623/article/details/123145942">CSDN文章<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info">.article-copyright-info-container{position:relative;width:100%;box-sizing:border-box;padding:10px 6px;font-size:1rem;background:var(--second-background-color);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--default-text-color)}&:last-child{margin-bottom:0}</div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">#中间件</a>&nbsp;</li><li class="tag-item"><a href="/tags/Redis/">#Redis</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/09/13/%E3%80%8CRedis%E3%80%8D%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">「Redis」关于缓存与数据库的一致性问题</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/09/04/%E3%80%8CJava%E3%80%8DThreadLocal%E7%AC%94%E8%AE%B0/"><span class="title flex-center"><span class="post-nav-title-item">「Java」ThreadLocal笔记</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"7e8652081d0a43a84cb4",clientSecret:"09dedf7315b0bb397fda7165e8c883e1605706e3",repo:"blog-comments",owner:"twq2000",admin:["twq2000"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">twq</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么要用Redis？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">Redis的过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU%E7%AE%97%E6%B3%95"><span class="nav-number">3.0.1.</span> <span class="nav-text">LRU算法</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">Redis的线程模型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">Redis支持的数据结构及其操作命令</span></a></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>