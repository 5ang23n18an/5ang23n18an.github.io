[{"title":"「Git」 一机多Git账号","url":"/2022/06/19/%E3%80%8CGit%E3%80%8D%E4%B8%80%E6%9C%BA%E5%A4%9AGit%E8%B4%A6%E6%88%B7/","content":"前言最近找了一份实习工作，然后就多出了一个通过公司邮箱注册的新的GitHub账号，工作日都是用这个账号来提交内容的。\n但是我自己还有一个个人的GitHub账号，有时在工作之余我也会用个人账号提交一些自己的内容。如此一来，我需要频繁地切换账号。如果每次都要在切换使用前重置并生成新的SSH公钥&amp;私钥，就显得太麻烦了！所以，本文就记录一下「如何在一台机器上配置多个GitHub账号」。\n\n\n过程\n清空全局范围下的username和email：\ngit config --global --unset user.namegit config --global --unset user.email\n\n设置一个新的username和email（注意这里不带 --global 参数）：\ngit config user.name &quot;wqtang-sib&quot;git config user.email &quot;wqtang@standardintbank.com&quot;\n\n生成每个账号对应的SSH公钥&amp;私钥：\nssh-keygen -t rsa -f ~/.ssh/twq2000 -C &quot;twq2000&quot;ssh-keygen -t rsa -f ~/.ssh/wqtang-sib -C &quot;wqtang-sib&quot;\n\n切换至用户目录下的 .ssh/ 文件夹，并创建一个名为 config 的文件：\ncd ~/.ssh/touch config\n\n编辑 config 文件，输入以下内容：\n# twq2000# Host 名是随意的，只是作为一个标识Host git1.github.com# HostName 填入你的远程仓库的所在域名HostName github.comPreferredAuthentications publickey# User 是任意的，可以选择与 GitHub 的账号名保持一致User twq2000# 指定该账号对应的 ssh 文件路径IdentityFile ~/.ssh/twq2000# wqtang-sib# Host 名是随意的，只是作为一个标识Host git2.github.com# HostName 填入你的远程仓库的所在域名HostName github.comPreferredAuthentications publickey# User 是任意的，可以选择与 GitHub 的账号名保持一致User wqtang-sib# 指定该账号对应的 ssh 文件路径IdentityFile ~/.ssh/wqtang-sib\n\n添加ssh文件记录：\nssh-agent bashssh-add -D # 先清空本地的 SSH 缓存ssh-add ~/.ssh/twq2000ssh-add ~/.ssh/wqtang-sib\n\n测试结果：\n# 这里的 git1.github.com 就是前面配置的 Host 名ssh -T git@git1.github.com# 这里的 git2.github.com 就是前面配置的 Host 名ssh -T git@git2.github.com\n\n如果能够分别显示正确的账号名与欢迎语句，那么就配置成功了！！~\n\n\n","tags":["Git","环境配置"]},{"title":"「Git」 入门总结","url":"/2022/05/18/%E3%80%8CGit%E3%80%8D%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/","content":"基础指令创建仓库\n在本地初始化一个仓库\ngit init\n\n从云端下载完整仓库到本地\ngit clone username@host:/path/to/repository\n\n\n\n本地git管理\n查看文件的修改状态\ngit status\n\n将文件从工作区移至暂存区\ngit add &lt;文件名&gt;\n\n将文件从从暂存区移至本地仓库\ngit commitgit commit -a # 可以把还没有执行add命令的文件也一起提交，即可以省去 git add 的过程（但是仅对于修改/删除文件有效，新文件还是要先 git add）git commit -m &quot;注释&quot; # 添加提交信息\n\n查看历史commit记录及其commit_id\ngit log\n\n回退至某个commit版本\ngit reset --hard commit_id\n\n将指定文件添加至忽略列表，不参与git的管理\n首先需要在工作目录下创建一个名为 .gitignore 的文件（必须是这个固定名）：\ntouch .gitignore\n\n然后在该文件中，指出需要忽略的文件（支持通配符），如 *.a ，那么所有 a 类型的文件都不再被git管理，自然也就不会提交至远端服务器了。\n\n\n\n\npush&#x2F;pull\n将本地仓库推送至云端\n首先，需要将你的本地仓库与远程仓库建立一个连接，例如：\ngit remote add origin username@host:/path/to/repository\n\n然后，就可以向这个远程仓库发送文件啦！\ngit push origin master# 将本地分支关联到远程分支上git push --set-upstream origin master# 后续就直接使用无参指令就可以了git push\n\npush有很多参数，其中有一个 -u 的参数比较实用。\n简单来说，使用了 git push -u origin master 后，就建立了一个和远端分支的关联关系。这样，就可以直接使用不带任何参数的 git pull 从之前push到的分支来pull，而不必再输入完整的 git pull origin master 了。同样，后续在推送代码时，也不必再完整输入 git push origin master ，而是直接 git push 就可以推送到这个远端分支了！\n后续，可以使用 git branch -vv 来查看这些关联关系。\n\n从云端仓库拉取文件\ngit pull\n\n其中，git pull &#x3D; git fetch + git merge，即先抓取，再与本地分支进行合并。\ngit fetch 就是将远程仓库中的更新内容都抓取到本地，但不会进行合并。\n\n\n可能会有疑惑：git pull 和 git clone 有什么区别呢，不都是从云端获取内容吗？\ngit clone 是一个从无到有的过程：在本地没有版本库的时候，从云端服务器获取整个版本库下载到本地。因此，它通常是初始时的第一步。\ngit pull 是在本地已有版本库的前提下，从云端服务抓取最新内容（如果有的话），再merge合并至本地。\n\n\n合并冲突：\nA和B修改了同一个文件的同一行代码，然后A先推送到了远程仓库，B后推送，那么这时候B就会发生合并冲突。\n解决合并冲突：\nB需要先 git pull 拉取一次远程仓库的提交，然后在本地完成合并冲突的处理，最后再提交推送至远程仓库。\n以上操作流程属于是一种经验了，可以在无论什么情况下都这么做（因为你不可能寄希望于自己是第一个提交推送的人）。\n\n\n\n\n使用分支使用分支，意味着可以把个人的工作与开发主线分离开，以免影响开发主线。当个人工作完成后，又可以再合并回开发主线。\n分支就好像单机游戏中的存档，可以创建分支（创建新存档），也可以切换至其他分支（读取其他存档），还可以合并分支（覆盖存档）。\n\n创建新分支\ngit branch &lt;新分支名称&gt;\n\n切换分支\ngit checkout &lt;目标分支名称&gt;\n\n如果你想切换至某个特定的版本，那么可以根据 commit id 来进行指代：\ngit checkout &lt;commit_id&gt;\n\n另外，也可以直接切换至一个不存在的分支（相当于创建+切换），加上参数 -b 即可：\ngit checkout -b &lt;目标分支名称&gt;\n\n将目标分支合并至当前分支\ngit merge &lt;目标分支名称&gt;\n\n删除分支\ngit branch -d &lt;目标分支名称&gt;\n\n这通常是在向主线分支合并完成后，就可以删除无用的副分支。\n\n查看分支\ngit branch # 本地分支git branch -r # 远程分支git brance -a # 查看所有分支\n\n\n\n经验总结\n在切换分支前，先提交本地的修改！！！\n勤提交，以保证不会丢失！！！\n\n\n\n一些trick自定义别名配置为那些常用但较长的指令，配置一个简短的别名，方便自己的命令书写！\n\n在用户目录下，创建 .bashrc 文件\ntouch ~/.bashrc\n\n在 .bashrc 文件中以键值对的形式，进行别名配置，如：\nalias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n使配置文件生效：\nsource ~/.bashrc\n\n\n\n我的常用git指令：\n查看git版本流水git log --pretty=oneline --abbrev-commit --all --graph# 自定义别名# 用于输出git提交日志# 以后，直接使用 git-log 就行了alias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n\n\n强制覆盖本地代码git fetch --allgit reset --hard origin/mastergit pull\n\n\n","tags":["Git"]},{"title":"「Spring」Transactional注解","url":"/2022/08/21/%E3%80%8CSpring%E3%80%8DTransactional%E6%B3%A8%E8%A7%A3/","content":"前言在Spring框架下的Java开发中，如果需要涉及到数据库的操作，且需要使用事务，可以直接使用Spring框架推荐的声明式事务的方式：@Transactional注解。\n所谓事务，就是将多条SQL操作视为一个整体，一起提交执行。结果是要么全部成功，要么就全部失败。如果出现失败，会将本次操作的数据回滚到之前的状态。\n但是，并不是加了这个注解就可以高枕无忧了。如果使用不当，那么事务依然是不生效的！\n\n\n事务失效的几个场景\n默认情况下，不支持针对Exception异常进行回滚：\n@Transactionalpublic boolean test() throws Exception &#123;    boolean success = mapper.updateById(1);    try &#123;        int a = 2 / 0;        // do something else...    &#125; catch (Exception e) &#123;        throw new Exception();    &#125;    return success;&#125;\n\n以上代码，我们知道程序肯定会在 2/0 这个地方产生运算异常，然后执行catch块中的内容，最终抛出Exception异常。\n但是，在默认情况下，@Transactional注解只会针对RuntimeException及其子类异常进行回滚操作。所以上述代码，其实事务是失效的。\n如果你去看看数据库，会发现这条数据已经被更新了，说明确实没有发生回滚操作。\n\n二次调用事务方法，事务失效\n@Transactionalpublic void update() &#123;    boolean success = articleMapper.update();    if(!success) &#123;        throw new RuntimeException(&quot;update error&quot;);    &#125;&#125;public void test() &#123;    update();&#125;\n\n以上代码，如果调用的是 test() 方法，那么事务是不会生效的。\n原因是：Spring的事务，是通过创建出来的代理对象来调用并提交&#x2F;回滚。而如果直接通过某个其他方法调用，就等于没有走代理方法调用，所以就导致事务失效了。\n\n非public作用域的方法，事务失效\n@Transactionalvoid update() &#123;    boolean success = articleMapper.update();    if(!success) &#123;        throw new RuntimeException(&quot;update error&quot;);    &#125;&#125;\n\n以上代码，也不会使事务生效。\n原因和情况2差不多，本质都是因为没有走代理方法调用：Spring在扫描@Transactional注解的时候，如果这个方法不是public修饰，就不会创建代理对象，也就没有代理方法的调用。\n\n\n\n\n总结\n@Transactional只能回滚RuntimeException及其子类的异常。如果程序抛出的异常不在此范围内（如Exception），则无法达到回滚的效果。\n如果需要支持回滚Exception异常，就必须显式地声明出来：@Transactional(rollbackFOr = Exception.class)。\n因此，为了保险起见，一般建议直接使用@Transactional(rollbackFOr = Exception.class)，以此保证当程序出错后，在抛出任何异常的情况下都可以实现回滚。\n\n如果由不带有@Transactional注解的方法A，去调用一个带有@Transactional注解的方法B，那么事务是不会生效的。\n\n如果@Transactional注解修饰的方法是非public的，那么事务也是不会生效的。\n\n\n","tags":["Spring"]},{"title":"「MySQL」JSON字段使用注意","url":"/2022/08/07/%E3%80%8CMySQL%E3%80%8DJSON%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","content":"\n对于json类型中的属性值，是严格区分大小写的\nselect *from tbwhere account -&gt;&gt; &#x27;$.name&#x27; like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;);\n\n以上，执行后的结果集表明：是对大小写敏感的。\n如果想要保持不区分大小写，一个可行且简单的思路是 将两边都转为小写，然后再进行比对：\nselect *from tbwhere lower(account -&gt;&gt; &#x27;$.name&#x27;) like lower(concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;));\n\n\n\n对于json类型中的null值属性，需要通过 cast(&#39;null&#39; as json) 来判断\nselect *from tbwhere json_extract(account, &#x27;$.name&#x27;) is null;\n\n以上，并不能得到预期的正确结果。\n如果想要判断json字段中的一个属性是否为空，那么是不能使用 is null 的，而是使用函数 cast(&#39;null&#39; as json)：\nselect *from tbwhere json_extract(account, &#x27;$.name&#x27;) != cast(&#x27;null&#x27; as json);\n\n","tags":["实习记录"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己注册组件！","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，实现自动将组件注册入IOC容器（不用再为每个需要注册的类手写 @Component 、 @Service 等注解），只需要关心业务代码本身即可。\n\n@Import@Import 支持三种使用姿势：\n带有 @Configuration 的 JavaConfig 配置类这也是平时使用的最多的方式就是第一种了，例如有一个主配置类 SpringConfiguration ，现在还需要声明并注册一些数据库相关的组件Bean。当然可以继续写在当前主配置类中，但是组件一旦变得多起来，日后查找就相当烦恼了。更清晰的一种编写方式是：将数据库相关的内容拆分出去，例如新建一个类 JdbcConfiguration ，然后主配置类与数据库配置类之间可以通过 @Import 进行引入。\n\n\n实现 ImportSelector 接口，并自定义其中的规则可以通过实现 ImportSelector 接口和 ImportBeanDefinitionRegistrar 接口，并在其中自定义我们自己想要的注册规则，实现自动批量注册组件等操作。\n观察接口的源码，发现有一个名为 selectImports 的方法需要我们去实现。\n\n\n\n实现类代码/** * 自定义 ImportSelector * 实现功能：将组件批量注册入IOC容器 */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并初始化赋值全局变量   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：将类批量注册入IOC容器   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // 存储扫描包的集合    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\n可以看到，我在无参构造函数中，是通过读取配置文件来获取用户指定的扫描包的。\n配置文件# ImportSelector 相关# AspectJ表达式：twq包下的 任意子包的 任意类custom.importSelector.expression=twq..*# 在上述规则成立的前提下，用户可以指定具体的扫描包custom.importSelector.package=twq# ImportBeanDefinitionRegistrar 相关custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\n对应到我的项目的文件夹路径，是这样的：\n\n    \n    \n    红框部分，就是我配置文件中配置的扫描包范围：twq包（包括子包）下的所有类\n\n\n\n\n最后，在主配置类上引入 @Import(CustomImportBeanDefinitionRegistrar.class) 即可。\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\n可以看到，我既没有在配置类上写 @ComponentScan ，也没有在任何业务类上写例如 @Component 、 @Service 等注解。\n\n\n测试结果现在让我们去测试一下，看看是否可以同样达到组件注册的效果。\n\n    \n    \n    可以看到，这些组件都被成功注册，调用方法也正常执行\n\n\n\n    \n    \n    另外，通过输出当前IOC容器组件名可知：自动为它们分配的id是各自的全限定名。\n\n\n\n\n实现 ImportBeanDefinitionRegistrar 接口，并自定义其中的规则我们来看一下 ImportBeanDefinitionRegistrar 接口的实现姿势。其实它与 ImportSelector 的实现思路基本一致。\n实现类代码/** * 自定义 ImportBeanDefinitionRegistrar * 实现功能：将组件批量注册入IOC容器 */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并给一些全局变量赋值   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：通过指定扫描包，自动将组件注册入IOC容器   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // 扫描集合中的这些包    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\n配置类代码@Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\n测试结果\n\n这里要说明一下：虽然在上面的图片中，看到相关注解的属性爆红了：idea表示无法解析这个bean name。这是因为我们根本没有写任何 @Component ，idea 还以为不存在这些组件。但其实我们已经通过 ImportBeanDefinitionRegistrar 接口帮我们进行组件注册了，所以测试结果是没问题的~~ :laughing:\n\n\n总结：\nImportSelector 自动注册时，分配的组件名规则是：各自类的全限定名 。\n\nImportBeanDefinitionRegistrar 自动注册时，分配的组件名规则是：各自类的类短名+首字母小写的注入方式 。\n\n\n","tags":["Spring","Java"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己读取yaml文件！","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，通过实现 PropertySourceFactory 接口，使Spring可以读取 yaml 格式的配置文件。\n\n@PropertySource我们知道，@PropertySource默认支持读取的是 .properties 和 .xml 格式的配置文件。\n不过就目前而言，更受欢迎且主流的配置文件格式是 .yml 。但很遗憾的是，Spring原生并不支持。\n那么，只好自己动手丰衣足食吧~ :thinking:\n所以接下来就自己实现一个可支持 .yml 格式的 @PropertySource ~\n\n\n源码分析首先点进来这个 @PropertySource 分析一番。可以看到这里需要的是一个解析器工厂类，接口为 PropertySourceFactory ，而框架提供的默认实现类是 DefaultPropertySourceFactory 。\n\n\n\n那么我们就照猫画虎，实现一个自己的 `CustomPropertySourceFactory` 。\n\n\n\n实现实现思路就是：将 yaml 文件解析并转为 properties 文件，然后再交由Spring去读取。\n这里我选择导入第三方依赖 snakeyaml ，以帮助我们解析 yaml 文件并转为 properties 文件。\n实现类代码/** * 自定义 PropertySourceFactory * 实现功能：允许读取yml格式的配置文件 */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // 创建一个yaml文件解析工厂    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // 将传入的资源解析为 properties 文件。这样，spring就支持读取了    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\n至此，就可以愉快地将配置文件改为 .yml 格式的啦。但是别忘了将 @PropertySource 的 factory 属性指向自己自定义的工厂解析类哦~\n\n\n配置类代码@Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Spring","Java"]},{"title":"「Spring」 框架知识点梳理宝典","url":"/2022/05/23/%E3%80%8CSpring%E3%80%8D%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%E5%AE%9D%E5%85%B8/","content":"Spring为什么要用Spring？\n控制反转\n通过依赖注入的方式，降低组件之间的耦合程度。由IoC容器来负责创建、管理对象的生命周期和配置。\nIoC的注入方式有两种：构造器注入、setter方法注入\n\nAOP技术\nSpring支持面向切面的编程方式，将一些与业务逻辑本身无关，且被多个业务所共用的操作（事务处理、打印日志、权限控制……）抽取出来。\n这样做的好处是可以减少重复代码，并且有利于未来的可拓展性和可维护性。\n它的原理是在编译时&#x2F;运行时，通过动态代理的方式实现程序功能的统一维护的一种技术。例如 AspectJ 就是在编译时进行动态代理的，SpringAOP 是在运行时进行动态代理的。\n\n支持事务管理\nSpring实现事务有两种方式：声明式和编码式。声明式事务又有两种方式：xml配置方式、@Transaction 注解方式。\n\n\n\n\n说说bean的声明周期流程？首先，上图！！\n\n\n\n然后，文字版再描述一下：\n\nSpring容器从配置文件中找到关于这个Bean的定义信息，利用反射技术创建出一个实例对象\n\n如果这个Bean还需要对其属性值进行一些设置，那么再利用setter方法进行对应的赋值\n\n检查这个Bean是否实现了 Aware 相关的接口。如果是，那么调用对应的方法。\n例如：\n\n如果实现了 BeanNameAware 接口，那么调用 setBeanName() 方法，传入Bean的名字\n如果实现了 BeanClassLoaderAware 接口，那么调用 setBeanClassLoader() 方法，传入ClassLoader对象实例\n…………\n\n\n如果这个Bean存在相关的 BeanPostProcessor 对象，那么执行 postProcessBeforeInitialization() 方法\n\n如果这个Bean实现了 InitializingBean 接口，那么执行 afterPropertiesSet() 方法\n\n如果这个Bean在配置文件中定义了 init-method，那么执行指定的方法\n\n如果这个Bean存在相关的 BeanPostProcessor 对象，那么执行 postProcessAfterInitialization() 方法\n\n当销毁这个Bean的时候，如果它实现了 DisposableBean 接口，那么执行 destory() 方法\n\n当销毁这个Bean的时候，如果它在配置文件中定义了 destory-method，那么执行指定的方法\n\n\n\n\nbean的作用域有哪些？\nsingleton：每一个bean只创建一个实例。这是默认的作用域。\n\nprototype：每次对bean的调用都会生成一个新的实例。\n\nrequest：在一个 http request 中，一个bean对应一个实例。 \n\nsession：在一个 http session 中，一个bean对应一个实例。 \n\nglobal session：在一个全局的 http session 中，一个bean对应一个实例。\n\n\n\n\n单例bean是线程安全的吗？首先，Spring对于单例模式的实现，使用的是 volatile+DCL 的懒汉式单例模式。这种实现方式，可以保证读操作的线程安全。\n在写操作的情境下，就存在线程安全问题了。这主要是因为：当多个线程同时操作一个对象的时候，对于这个对象的非静态成员变量的写操作会存在线程安全问题。\n对此，常见的解决方法有：\n\n在bean对象中尽量避免定义可变的非静态成员变量（然而并不现实）\n\n在需要保障线程安全的场景下，选择prototype多例模式\n\n在类中定义一个ThreadLocal成员变量，将需要的可变成员变量，都保存在ThreadLocal中\n\n关于ThreadLocal，我当时在学习的时候也写过一篇文章，用于记录：🔗 「Java」ThreadLocal笔记\n\n\n\n\n\n@Component和@Bean的区别是什么？\n@Component注解作用于类上；@Bean注解作用于方法上\n\n@Component通常是通过类路径扫描（使用@ComponentScan来定义路径）的方式，将某个类自动装配到Spring容器中；@Bean通常将某个方法的返回值作为一个bean交给Spring容器进行管理，当需要的时候直接问Spring拿。\n也正因为这一点，所以@Bean的灵活性是更强的，很多时候我们只能通过@Bean的方式来进行注册。比如，当我们需要引用第三方类库中的对象时，就只能通过@Bean来实现。\n\n\n@Bean注解使用示例：\n@Configurationpublic class AppConfig &#123;    @Bean    public UserService userService() &#123;        return new UserServiceImpl();    &#125;        // 这个例子（存在逻辑判断），是无法通过 @Component 来实现的    @Bean    public TransferService transferService(int status) &#123;        switch(status) &#123;            case 1:                return new TransferServiceImpl1();            case 2:                return new TransferServiceImpl2();            case 3:                return new TransferServiceImpl3();        &#125;    &#125;&#125;\n\n\n\nAOP的动态代理策略是怎样的？如果目标对象实现了接口，那么会默认采用JDK动态代理（也可以强制指定为CGLib动态代理）；否则，会强制采用CGLib动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n常用注解及其含义\n\n\n注解\n作用\n\n\n\n@Value\n将常量、配置文件中的变量值，注入到一个变量中\n\n\n@RequestMapping\n用于映射web请求，搭配@Controller一起使用\n\n\n@RequestParam\n接收请求路径中的参数，如 &#x2F;user?id&#x3D;123\n\n\n@PathVariable\n接收路径参数，如 &#x2F;user&#x2F;123\n\n\n@RequestBody\n接收json等格式数据，并注入给指定形参对象\n\n\n@ResponseBody\n将返回对象以某种形式的字符串返回给前端（一般是JSON、XML）\n\n\n@Qualifier\nby name匹配模式，搭配@Autowired一起使用，从而消除注入歧义\n\n\n@Component\n标注在类上，表示当前类是一个组件，要交由Spring来进行管理\n\n\n@Configuration\n标注当前类是一个Java Config类，Spring可以将它视作定义bean的配置类\n\n\n@Bean\n标注在具有返回值的方法上，将其返回值对象作为一个bean注册入IoC容器中\n\n\n\n\nSpring MVCSpring MVC 的工作流程？流程图：\n![img](&#x2F;images&#x2F;Spring MVC 的工作流程.jpg)\n\n\n接下来，根据上述的流程图，结合文字进行说明：\n\n客户端发起请求，直接来到了 DispatcherServlet\nDispatcherServlet 根据请求信息，在 HandlerMapping 中选择一个合适的处理器（也就是我们编写的Controller层）来处理这次请求\n将这个Handler给到请求适配器 HandlerAdapter，然后就会调用处理器，进行业务逻辑处理\n处理完成后，处理器会返回一个 ModelAndView 对象，然后交由视图解析器 ViewResolver 进行视图解析\n视图解析完成后，将解析结果交还给 DispatcherServlet，然后由 DispatcherServlet 进行视图的最终渲染（将数据填充到request域），最后返回response响应给客户端\n\n\n\nRestful风格是什么？Restful就是一个资源定位及资源操作的风格。它不是标准也不是协议，只是一种风格。\n\nURI只是作为资源的代表形式\n\n客户端使用 GET、POST、PUT、DELETE 这四种操作方式对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源\n在服务端，分别对应的注解标识是：@GetMapping, @PostMapping, @PutMapping, @DeleteMapping。\n以 @GetMapping 为例，它其实就是 @RequestMapping(method = RequestMethod.GET) 的缩写。其他同理。\n\n\n\n\nRestful风格的好处是，它允许请求路径相同，但请求参数不同或请求方式不同的情况。如果是传统方式，如果有两个相同的映射路径就会直接报错。\n在Restful风格下，根据不同的参数和请求方式，会执行不同的方法，最终产生的结果也不同，因此就不存在同路径时的冲突问题。\n以下是一个示例：\n@Controllerpublic class TestController &#123;    @GetMapping(&quot;/add&quot;)  @ResponseBody  public String add1(int a, int b) &#123;    return &quot;add1:&quot; + String.valueOf(a + b);  &#125;    @GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)  @ResponseBody  public String add2(@PathVariable int a, @PathVariable int b) &#123;    return &quot;add2:&quot; + String.valueOf(a + b);  &#125;    @PostMapping(&quot;/add&quot;)  @ResponseBody  public String add1(int a, int b) &#123;    return &quot;add3:&quot; + String.valueOf(a + b);  &#125;&#125;\n\n\n\n如果访问 “&#x2F;add?a&#x3D;1&amp;b&#x3D;2”，那么在页面上就会显示 “add1:3” 字符串；\n如果访问 “&#x2F;add&#x2F;3&#x2F;4”，那么在页面上就会显示 “add2:7” 字符串；\n如果访问 “&#x2F;add?a&#x3D;1&amp;b&#x3D;2”，且提交方式是POST请求，那么在页面上就会显示 “add3:3” 字符串。\n\n\n@RestController根据官方文档：\n\n@RestController is a stereotype annotation that combines @ResponseBody and @Controller.\n\n意思是：&#96;&#96;@RestController=@ResponseBody＋@Controller。也就是说：使用 @RestController，意味着这个类中的所有方法上面都加了 @ResponseBody&#96;。\n至于 @ResponseBody 的作用，就是将返回对象以某种形式的字符串返回给前端（一般是JSON、XML）。\n总之，用 @Controller，返回的是页面；用 @RestController，返回的是JSON、XML或其他文本格式的字符串。\n\n\n下面举个例子，来感受一下 @ResponseBody 的作用：\n@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/login1&quot;)  public String login1() &#123;    return &quot;login&quot;;  &#125;    @RequestMapping(&quot;/login2&quot;)  @ResponseBody  public String login2() &#123;    return &quot;login&quot;;  &#125;&#125;\n\n\n\n如果访问 “&#x2F;user&#x2F;login1”，那么返回的就是 login 页面，如 login.html；\n如果访问 “&#x2F;user&#x2F;login2”，那么在页面上就会显示 “login” 字符串。\n\n\n@RequestBody通过 @RequestBody，可以将请求体中的JSON字符串绑定到相应的方法参数上的对象。\n下面举个例子：\n前端请求发送代码：\n$.ajax(&#123;  url: &quot;/login&quot;,  type: &quot;POST&quot;,  data: &#123;    username: $(&quot;#username&quot;).val(),    password: $(&quot;#password&quot;).val()  &#125;,  success: function(data) &#123;    // ....  &#125;&#125;)\n\n\n\n后端接收代码：\n@RequestMapping(&quot;/login&quot;)public void login(@RequestBody String username, @RequestBody String password) &#123;  // ....&#125;\n\n\n\n这种情况是将请求中的JSON字符串的不同变量分配给了不同的形参对象来接收数据。\n但是如果将 username 和 password 字段进行封装，产生一个 User 类，那么上述代码可以改写为：\n@RequestMapping(&quot;/login&quot;)public void login(@RequestBody User user) &#123;  // ....&#125;\n\n\n\n框架会自动将JSON字符串中的每个值赋予到 user 对象中对应的属性上。不过，必须确保JSON字符串中的每个key都有对应的对象中的属性名，否则是无法顺利接收的！\n\n\nSpringBootSpringBoot是什么？它基于Spring框架，可以帮助使用者快速构建一个准生产级别的项目。\n\n由于Spring框架中需要进行大量的配置，且很多都是固定重复的，因此，SpringBoot预先对这些部分已经做好了习惯性的配置，使用者可以不用或者只需进行很少的手动配置。\n引入了 SpringBoot Starters 来解决依赖之间可能因版本冲突导致的问题。\n\n\n\n@SpringBootApplication 注解的含义@SpringBootApplication 包含了：\n\n@ComponentScan\n\n@SpringBootConfiguration（本身就是一种 @Configuration）\n\n@EnableAutoConfiguration\n在这个注解中，又包含了不少注解。但是，最关键的一个是 @Import(EnableAutoConfigurationImportSelector.class)。借助它，SpringBoot可以将所有符合要求的 JavaConfig 配置类都自动加载到IoC容器中。\n\n\n\n\nSpringBoot加载配置文件的优先级顺序？由高到低：\n\nfile: .&#x2F;config&#x2F;application.properties\nfile: .&#x2F;application.properties\nclasspath: resource&#x2F;config&#x2F;application.properties\nclasspath: resource&#x2F;application.properties\n\n\n其中，file 代表项目文件的主目录；classpath 代表项目的类路径。\n\n","tags":["Spring","八股文"]},{"title":"「String」 String不可变类的原因","url":"/2022/06/02/%E3%80%8CString%E3%80%8DString%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/","content":"什么是不可变？《Effective Java》中对于不可变对象的定义是：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。这就意味着，一旦我们将一个对象分配给一个变量，就无法再通过任何方式更改对象的状态了。\n在 String 中，不可变的表现就是当我们试图对一个已有的对象 “abc” 修改为 “abcd” 时，会直接创建一个新对象：\nString s = &quot;abc&quot;;// 这里 s 的引用地址已经发生改变了，指向了一个新的对象s = &quot;abcd&quot;;\n\n\n\nString 是如何做到不可变的？String 真正存储字符内容的地方是一个 char 数组，并且被 final 所修饰，所以无法被修改：\nprivate final char[] value;\n\n但是！！！这里说的无法被修改，仅仅是指它的引用地址不可被修改，并不代表它本身的内容不可变！！\n引用地址不可被修改：\nfinal char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;// 编译器报错value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;\n\n本身的内容是可变的：\nfinal char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;// 这是完全可以的value[0] = &#x27;d&#x27;;\n\n\n\n这么说来，如果回答 ”String 真正存储字符内容的地方是一个 char 数组，并且被 final 所修饰，所以无法被修改“，就不完全正确。\n\nString 中的 char 数组是 private 的，并且 String 类没有对外提供修改这个数组的方法。所以在初始化之后，外界没有有效的手段去修改它；\nString 类被 final 修饰，也就是不可继承的，这样可以避免被子类继承后被破坏了不可变性；\n在 String 的所有方法里面，都很小心地避免直接修改 char 数组中的内容。所有涉及到对 char 数组中数据进行修改的操作，全部都会创建一个新的 String 对象。\n\n\n\n为什么要将 String 设计为不可变？\n字符串常量池\n回顾一下字符串常量池的定义。在大量频繁地创建字符串的场景下，会极大程度地影响程序的性能。JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：\n\n为字符串开辟了一个字符串常量池 String Pool，可以理解为缓存区。\n创建字符串常量时，首先检查字符串常量池中是否存在该字符串？\n若字符串常量池中存在该字符串，则直接返回该引用实例，无需重新实例化；若不存在，则先实例化该字符串，然后放入池中。\n\n下面的代码，只会在堆中创建一个实例：\nString str1 = &quot;hello&quot;;String str2 = &quot;hello&quot;;System.out.println(str1 == str2); // true\n\n\n试想一下：如果 String 是可变的，那么如果我们修改了 str1 的内容，那么 str2 也会被一起修改。但这显然不是我们想要的结果。\n\n保证线程安全\n作为最基础最常用的数据类型，String 被许多 Java 类库用来作为参数，如果 String 是可变的，就会引起各种线程安全的隐患。\n在多线程环境下，多个线程同时修改同一个资源，这是存在线程安全问题的。但 String 作为不可变对象，它不能被修改。想要修改，只能再创建一个新的对象；多个线程同时读同一个资源，是完全没有问题的。所以总的来说，这样做可以保证 String 是线程安全的。\n\n\n\n\nString 真的不可变吗？想要改变 String 无非就是改变 char 数组中的内容，但它是一个私有属性。那么在 Java 中有没有某种手段可以访问类的私有属性呢？\n那就是反射。使用反射当然可以直接修改 char 数组中的内容，从而修改 String 的内容，破坏了不可变性。\npublic void test() &#123;  String s = &quot;hello&quot;;  Field field = s.getClass().getDeclaredField(&quot;value&quot;);  // 允许获取私有属性  field.setAccessible(true);  // 获取 s 的 value 属性  char[] value = (char[]) field.get(s);  value[0] = &#x27;g&#x27;;  System.out.println(s); // &quot;gello&quot;&#125;\n\n只不过我们一般不会这么做，反射不在这里的讨论范围之内，毕竟 private 修饰符防君子不防小人！\n\n\n总结并不是因为 char 数组是 final 才使得 String 是不可变的，而是为了把 String 设计成不可变，所以才把 char 数组修饰为 final 的。\n\n\n一般来说，不可变类都遵循这些设计规则：\n\n不提供 setter 方法（包括修改字段的方法和修改字段引用对象的方法）\n将类的所有字段定义为 private final 的\n不允许子类重写方法。最简单的办法是将类声明为 final，更好的方法是将构造函数声明为私有的，对外界只提供工厂方法来创建对象\n\n","tags":["Java","八股文"]},{"title":"「macOS」🍎懵逼初指南","url":"/2022/05/28/%E3%80%8CmacOS%E3%80%8DmacOS%E4%B8%8A%E6%89%8B%E5%88%9D%E8%AE%BE%E7%BD%AE/","content":"自定义设置总体而言，几乎所有的自定义设置，都在「偏好设置」中。如果是系统级别的，就是「系统偏好设置」；如果是应用级别的，就是各应用中的「偏好设置」。\n\n\n系统偏好设置通用\n显示滚动条 —— 始终\n在滚动条中点按 —— 跳到点按的位置\n最近使用的项目 —— 关闭文稿时要求保存更改、退出App时关闭窗口\n\n\n\n程序坞\n打开文稿时首选标签页 —— 仅在全屏幕视图下\n连按窗口标题栏以 —— 缩放\n将窗口最小化为应用程序图标 —— 关闭\n弹跳打开应用程序 —— 打开\n为打开的应用程序显示指示灯 —— 打开\n在程序坞中显示最近使用的应用程序 —— 打开\n\n\n\n语言与地区 &amp; 日期与时间\n每周的第一天 —— 星期一\n时间格式 —— 24小时\n时钟 —— 使用24小时格式时钟\n\n\n\n用户与群组登录选项：\n\n自动登录 —— 关闭\n显示“睡眠”、“重新启动”和“关机”按钮 —— 打开\n将快速用户切换菜单显示为 —— 全名\n\n\n\n安全性与隐私\n允许从以下位置下载的App —— 任何来源\nsudo spctl --master-disable\n\n文件保险箱 —— 停用\n\n\n\n\n显示器\n排列 —— 主屏是上方有「白条」标识的\n\n\n\n节能\n此时间段后关闭显示器 —— 30分钟\n如果可能，使硬盘进入睡眠 —— 关闭\n使用电池电源时使显示屏略暗一些 —— 打开\n在菜单栏中显示电池状态 —— 打开\n当显示器关闭时，防止电脑自动进入睡眠 —— 打开\n\nApp推荐：Better Menubar\n\n\n访达高级：\n\n显示所有文件扩展名 —— 打开\n更改扩展名之前显示警告 —— 打开\n从iCloud云盘中移除前显示警告 —— 打开\n清倒废纸篓之前显示警告 —— 打开\n将以下位置的文件夹保持在顶部 —— 按名称排列时的窗口中\n执行搜索时 —— 搜索此Mac\n\n\n\n显示文件路径打开终端，输入以下命令：\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n这样就可以在Finder顶部看见完整地址了。复制路径使用 Option+Command+C\n右键地址栏区域，还可以直接访问路径中的任意一层。\n\n\n卸载方式\n应用程序自带的卸载程序\n使用第三方卸载工具（如 AppDelete），然后将需要卸载的应用图标拖入\n直接移除至废纸篓（可能会残留日志、用户数据缓存等文件）\n\n\n\n常用命令行查找目标文件的路径\n根据文件名查找路径\nmdfind -name &#x27;hello.txt&#x27;\n\n根据文件内容查找路径\nmdfind &#x27;hello world!&#x27;\n\n\n\n新建文本文件touch hello.txt\n\n\n\n推荐App工具列单 🏷️\nBetterAndBetter\n截图工具 iShot\n解压缩工具 Bandizip&#x2F;MyZip&#x2F;FastZip\n磁盘清理工具 CleanMyMac\n\n\n\n附图：Mac快捷键\n\n\n\n","tags":["环境搭建"]},{"title":"「vue」 基本语法小记","url":"/2022/06/06/%E3%80%8Cvue%E3%80%8D%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/","content":"参考链接：Vue基础语法\n这篇文章总结的实在是太好了，简直是入门党的福音！！\n","tags":["前端","转载"]},{"title":"「二分法」最硬干货，速进！","url":"/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81/","content":"前言二分法是一个广泛应用于计算机世界的经典算法，相信没有哪个程序员会不知道它。\n二分查找的本质是通过不断的判断，决定区间的取舍，最终夹出所需答案。使用二分法，可以让你在有序数组中，以 O(logn) 的时间复杂度，找到想要的答案。\n但是，网上关于二分的教学满天飞，大致分为 while (left &lt;= right)  和 while (left &lt; right) ，然后更新式又是五花八门：有的是 left = middle + 1 和 right = middle - 1 ，有的是 left = middle + 1 和 right = middle ……\n稍有不慎写错了，二分就进入了死循环 😭 本来是为了加速查找，这下好了，反向加速了属于是。\n\n\n所以，不多逼逼，直接上干货！\n模板代码统一使用 while (left &lt; right) ，并且：\n\n寻找第一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  int middle = left + (right - left) / 2;  if (满足XXX) &#123;    right = middle;  &#125; else &#123;    left = middle + 1;  &#125;&#125;\n寻找最后一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  // +1是为了让相除结果向上取整，这个地方就是两套模板的区别之一  int middle = left + (right - left + 1) / 2;  if (满足XXX) &#123;    left = middle;  &#125; else &#123;    right = middle - 1;  &#125;&#125;\n\n\n\n最终的二分结果，返回 left 或 right 都可，因为退出循环时一定有 left==right 。\n\n你可以把这两种模板都记住，也可以只选择其中一套看着更顺眼的。因为这两种模板之间的结果是可以互相转化的。\n假设你只会用 寻找第一个满足XXX 这个模板，但是遇到的实际需求是 寻找最后一个满足XXX ，那你也完全可以将二分目标动态地修改为： 寻找第一个不满足XXX 的位置（也就是把 if 条件 改成对应相反的，其余都不用动）。可知它的上一个位置就是 最后一个满足XXX 的，即：把得到的二分结果减去1，就是答案了。反之同理，由 最后一个 -&gt; 第一个 是 加1操作。\n\n\n不过，这样得到的结果，很多时候都需要进行 后处理判断 ，否则会带来问题。\n\n如果你是由 一种情况 转化到 另一种情况 的话，可能会带来 索引越界 的问题。这是因为：在结果转化时一定会进行 -1 (或者 +1) 的操作。那么假设本身的二分结果是0，然后再减1，变成-1了。\n所以在最后返回前，必须判断一下这个下标究竟是否合法（如果题目保证一定存在答案，那么大可放心不必进行这些判断）：\n\n\n// 这里用 -1 表示下标非法时的返回结果return left &gt;= 0 &amp;&amp; left &lt; nums.length ? left : -1;\n\n\n另外，如果题目不保证一定存在答案，那么即使没有产生 索引越界 ，也可能得到 错误答案 。\n例如 寻找有序数组中元素值为 target 的元素所在位置，但是并不保证它一定存在 。拿到这题，我便设定二分目标是： 寻找第一个满足 nums[i] &gt;= target 的位置 i ，最终我得到的二分结果是 left (同样也可以是 right ) 。可是我只知道 nums[left] &gt;= target 是没错的，但不代表 nums[left] == target 也一定没错，因为可能 target 压根就不存在于数组中！！\n所以就必须要后处理判断：\n\n\n// 这里用 -1 表示数组中不存在 target 的返回结果return nums[left] == target ? left : -1;\n\n\n\n最后，还是要啰嗦一下：如果题目保证答案是存在的，那么以上这些后处理的判断都是不必的，你得到的结果一定是正确的。当然，你总是进行后判断处理，那也是很严谨的~\n","tags":["算法","二分查找"]},{"title":"「动态规划」 股神养成记","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n前言股票问题系列 是动态规划入门的经典系列了。\n本文将收录 LeetCode 上的所有相关问题，以此总结股票市场的操作经验。\n\n\n题单汇总 🏷️LeetCode.121题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例1：\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出。\n\n示例2：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成。\n\n\n\n分析本题的要点：最多允许一次交易（买入+卖出）。而数组本身的长度，满足 prices.length&gt;=1 ，即：你想在哪个点位买入，随意任君挑选~并且，你不用考虑当前交易会对下次交易产生影响（因为只有一次交易，不存在下一次）。\n所以，在这种情况下，可以不考虑dp思想，退化为最naive的贪心策略：选择一个价格差最大的交易即可。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.122题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以 尽可能地 完成更多的交易（多次买卖一支股票）。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出）。除了不能同时参与多笔交易，没有任何其他限制条件。\n这种情况下，也完全可以将问题 退化为贪心策略：只要今天价格比昨天高，那么我就认为昨天已买入，然后在今天卖出。\n为什么这个策略是正确的？万一明天更高，但是我今天就卖出了，岂不是卖早了嘛？？\n其实并不会。可以看 示例2 ，你会发现：即使我在1块钱买入、2块钱卖出；然后我可以在2块钱又买入、3块钱再卖出；然后再是3块钱买入、4块钱卖出……总之，我最后依然可以赚取4元的利润，不会少的。嗯，本质是叫我们去做短线高手。懂了，学会这个操作思路，股神就是在下了。实际：死于做t\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.309题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n示例1：\n\n输入：prices &#x3D; [1,2,3,0,2]输出：3\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出），但除了不能同时参与多笔交易以外，每两笔交易之间还存在一天的冷冻期。\n这种情况下，贪心策略就不再好使了。因为，你必须考虑到：当前的交易会使得明天无法交易，所以“无脑短线”并不见得一定正确。 从此开始，dp策略正式亮相~\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; 第i天持有股票时，可获得的最大利润    // dp2[i] -&gt; 第i天未持有股票且未处于冷冻期，可获得的最大利润    // dp3[i] -&gt; 第i天未持有股票且处于冷冻期，可获得的最大利润    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\nLeetCode.123题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：最多允许两次交易（买入+卖出），并且不能同时参与多笔交易。\n这种情况下，贪心策略也不再好使了。原因也很容易理解：一共只有两次交易机会，你必须选择利润最大的两笔，而不是“一高就卖”，随意挥霍机会。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * 在任意一天结束后，会处于以下五种状态中的一种：   * 未进行过任何操作，最大利润永远是0   * 只进行过一次买入操作，最大利润以buy1表示；   * 进行过一次买入、一次卖出操作，最大利润以sell1表示；   * 进行过两次买入、一次卖出操作，最大利润以buy2表示；   * 进行过两次买入、两次卖出操作，最大利润以sell2表示。   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\nLeetCode.188题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2\n\n示例2：\n\n输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7\n\n\n\n分析本题与之前的不同之处在于：最多允许 两次 交易（买入+卖出），并且不能同时参与多笔交易。\n本题实质上，就是 题目4 – LeetCode.123 的扩展版本：硬编码 2 次机会 --&gt;  任意给定的 k 次机会。\n同样地，这里也理应无法使用贪心策略。\n但事实上，由于 k 的范围是任意的，所以情况也不完全是这样。例如：k=9999999（此处自行脑补一亿个9…），那么我们就可以认为 k 是无限大的，此时交易次数视为：不受限。\n事实上，只要有 k &gt;= prices.length / 2 ，此时就可以 无视次数限制了，因为你一定来不及用完所有的交易机会！如果没有交易次数限制，那么问题又可以退化为“贪心策略”了。 于是问题又变成了 题目2 – LeetCode.122 。\n除此以外，普遍情况下还是需要使用 dp策略 。\n\n\n代码class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // 当可操作次数不少于数组的一半长度时，问题可以退化为“贪心策略”    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; 完成i次买入后，可获得的最大利润    // dp[i][1] -&gt; 完成i次卖出后，可获得的最大利润    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["算法","动态规划"]},{"title":"「正则表达式」 语法与使用","url":"/2022/05/27/%E3%80%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%8D%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"前言正则表达式，又称规则表达式。其英语为 Regular Expression，在代码中常简写为 regex 。它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，从而实现一种过滤的逻辑效果。\n正则表达式是一种文本模式，描述了在搜索文本时要匹配的字符串的“样子”，因此通常被用来检索、替换那些符合该模式规则的文本，或者是检验一个文本是否符合该模式规则。\n\n\n基本语法\n\n\n表达式\n匹配内容\n\n\n\n[…]\n匹配封闭字符集中的任一字符\n\n\n[\\^…]\n不匹配封闭字符集中的任一字符\n\n\n.\n代表任意字符\n\n\n\\.\n代表文字句号 ‘.’\n\n\n\\d\n匹配一个数字\n\n\n\\d+\n匹配一个整数（+表示一个或多个）\n\n\n\\d?\n匹配一个可能存在的数字（?表示零个或一个）\n\n\n\\d*\n匹配一个可能存在的整数（*表示零个或多个）\n\n\n\\d{m}\n匹配m个数字\n\n\n\\d{m,n}\n匹配m~n个数字\n\n\n\\w\n匹配一个字母字符\n\n\n其中,+,*,&#123;m&#125;,&#123;m,n&#125; 这些都是数量表达式，可以跟在 [...],\\w 等任意字符表达式的后面，两者结合成为更加详细的字符串匹配表达式。\n\n\n不过，需要注意的是：在Java中使用这些正则表达式的语法时，对于任何特殊字符（如\\ 和 .）都需要两级转义，变成 \\\\ 和 \\. 。这是因为正则表达式本身也是一种字符串，也会被javac编译。因此想要得到预期的效果，就必须转义。\n\n\n例题应用LeetCode.65 – 有效数字题面\n有效数字（按顺序）可以分成以下几个部分：\n\n一个 小数 或者 整数\n（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n下述格式之一：\n至少一位数字，后面跟着一个点 ‘.’\n至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字\n一个点 ‘.’ ，后面跟着至少一位数字\n\n\n\n整数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n至少一位数字\n\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n\n示例：\n\n部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]\n部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final Pattern PATTERN = Pattern.compile(&quot;[+-]?((\\\\d+)|(\\\\d+\\\\.\\\\d*)|(\\\\d*\\\\.\\\\d+))([eE][+-]?\\\\d+)?&quot;);  public boolean isNumber(String s) &#123;    return PATTERN.matcher(s).matches();  &#125;&#125;\n\n\n\nLeetCode.468 – 验证IP地址题面\n给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。\n有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;&#x3D; xi &lt;&#x3D; 255 且 xi 不能包含 前导零。\n一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:\n\n1 &lt;&#x3D; xi.length &lt;&#x3D; 4\nxi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )\n在 xi 中允许前导零。\n\n\n示例：\n\n有效的IPv4地址: “192.168.1.1”, “192.168.1.0”\n无效的IPv4地址: “192.168.01.1”, “192.168.1.00”, “&#49;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x40;&#x31;&#46;&#x31;”\n有效的IPv6地址: “2001:0db8:85a3:0000:0000:8a2e:0370:7334”, “2001:db8:85a3:0:0:8A2E:0370:7334”\n无效的IPv6地址: “2001:0db8:85a3::8A2E:037j:7334”, “02001:0db8:85a3:0000:0000:8a2e:0370:7334”\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final String IP4_REGEX = &quot;((\\\\d)|([1-9]\\\\d)|(1\\\\d\\\\d)|(2[0-4]\\\\d)|(25[0-5]))&quot;;  private static final String IP6_REGEX = &quot;([\\\\d|[a-f]|[A-F]]&#123;1,4&#125;)&quot;;  private static final Pattern IPV4_PATTERN = Pattern.compile(IP4_REGEX + &quot;(\\\\.&quot; + IP4_REGEX + &quot;)&#123;3&#125;&quot;);  private static final Pattern IPV6_PATTERN = Pattern.compile(IP6_REGEX + &quot;(:&quot; + IP6_REGEX + &quot;)&#123;7&#125;&quot;);  public String validIPAddress(String queryIP) &#123;    if (IPV4_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv4&quot;;    &#125;    if (IPV6_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv6&quot;;    &#125;    return &quot;Neither&quot;;  &#125;&#125;\n\n","tags":["字符串","正则表达式"]},{"title":"「树」根据给定的前/中/后序遍历，以恢复二叉树","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"今天来记录两道经典二叉树的问题：\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树\n\n\n\n首先，为了构建出这棵二叉树，我们肯定是自顶向下，从 位于顶端的树根节点 出发，在每个正确的位置构造出正确的节点。在每次处理中，我们只关注如何 构造出当前节点 。\n而这个 节点 ：\n\n对于 先序遍历 ，就是 第一个 元素 preorder[preLeft] ；\n\n对于 后序遍历 ，就是 最后一个 元素 postorder[postRight]\n\n\n现在，这个根节点的 val 属性已经确定了，我们可以构造出当前节点： TreeNode root = new TreeNode(val);\n但是其 left 和 right 属性都是不确定的，它们作为子节点，此时并不存在。需要在之后的处理中将它们构造出来 (也就是递归调用) ： \nroot.left = buildTree();root.right = buildTree();\n\n接下来，我们将开始利用 中序遍历的性质。据前所述，我们可以根据 先序遍历 (or 后序遍历) 得到当前的根节点。那么，它在 中序遍历 中的位置，其实将整棵树分为了两半。\n我们假定 该根节点在中序遍历中的位置 是 rootIdx ，那么我们可知 左子树的节点个数 leftSize = rootIdx - inLeft ，由此可得到左右子树的区间范围：\n\n左子树：\n先序遍历： [preLeft + 1, preLeft + leftSize]\n中序遍历： [inLeft, rootIdx - 1]\n后序遍历： [postLeft, postLeft + leftSize - 1]\n\n\n右子树：\n先序遍历： [preLeft + leftSize + 1, preRight]\n中序遍历： [rootIdx + 1, inRight]\n后序遍历： [postLeft + leftSize, postRight - 1]\n\n\n\n至于如何能快速地根据先序遍历&#x2F;后序遍历的元素定位至它在中序遍历中的位置？\n答案是：在开始时，使用哈希表来预处理存储先&#x2F;后序遍历数组中的每个元素在中序遍历数组中的位置。\n\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["算法","二叉树"]},{"title":"「进制转换」 题单总结！","url":"/2022/06/05/%E3%80%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%8D%E9%A2%98%E5%8D%95%E6%80%BB%E7%BB%93/","content":"前言「进制转换」问题算是比较简单但又十分常考的面试题了。它可以很好的考察一个人对于计算机进制的理解，同时涉及到一些位运算。\n\n\n题单汇总 🏷️LeetCode.504 – 七进制数题面\n给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。\n\n示例 1:\n\n输入: num &#x3D; 100\n输出: “202”\n\n示例 2:\n\n输入: num &#x3D; -7\n输出: “-10”\n\n\n\n代码class Solution &#123;  public String convertToBase7(int num) &#123;    boolean neg = num &lt; 0;    if (neg) &#123;      num = -num;    &#125;    StringBuilder sb = new StringBuilder();    while (num &gt; 0) &#123;      sb.append(num % 7);      num /= 7;    &#125;    if (neg) &#123;      sb.append(&#x27;-&#x27;);    &#125;    return sb.isEmpty() ? &quot;0&quot; : sb.reverse().toString();  &#125;&#125;\n\n\n\nLeetCode.1017 – 负二进制转换题面\n给出数字 N，返回由若干 “0” 和 “1”组成的字符串，该字符串为 N 的负二进制（base -2）表示。\n除非字符串就是 “0”，否则返回的字符串中不能含有前导零。\n\n示例 1：\n\n输入：2\n输出：”110”\n解释：(-2) ^ 2 + (-2) ^ 1 &#x3D; 2\n\n示例 2：\n\n输入：3\n输出：”111”\n解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 &#x3D; 3\n\n\n\n代码class Solution &#123;  public String baseNeg2(int n) &#123;    boolean neg = false;    StringBuilder sb = new StringBuilder();    while (n &gt; 0) &#123;      sb.append(n &amp; 1);      n = neg ? (n &gt;&gt; 1) + (n &amp; 1) : n &gt;&gt; 1;      neg ^= true;    &#125;    return sb.isEmpty() ? &quot;0&quot; : sb.reverse().toString();  &#125;&#125;\n\n\n\nLeetCode.1837 – K 进制表示下的各位数字总和题面\n给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。\n转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。\n\n示例 1：\n\n输入：n &#x3D; 34, k &#x3D; 6\n输出：9\n解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 &#x3D; 9 。\n\n示例 2：\n\n输入：n &#x3D; 10, k &#x3D; 10\n输出：1\n解释：n 本身就是 10 进制。 1 + 0 &#x3D; 1 。\n\n\n\n代码// todo","tags":["算法"]},{"title":"「MyBatis」浅记一哈","url":"/2022/06/11/%E3%80%8CMyBatis%E3%80%8D%E6%B5%85%E8%AE%B0%E4%B8%80%E5%93%88/","content":"映射器配置我会配合着实例来说明，而几乎所有的例子都会使用一个 User 类型的 JavaBean，所以我在这里先给出它的定义：\npublic class User &#123;    private Long id;    private String userName;    private String password;    private String address;        // getter &amp; setter...&#125;\n\n另外，创建一个与之对应的接口 UserMapper，其中定义了几个基本操作方法：\n@Mapperpublic interface UserMapper &#123;    public User getById(Long id);    public void insert(User user);    public void delete(Long id);&#125;\n\n\n\n&lt;select&gt;初识select 可以算作是最常用的元素了，因为几乎任何业务都会涉及查询操作。\n我们先看一下最基本的使用方式：\n&lt;select id=&quot;getById&quot; resultType=&quot;twq.entity.User&quot; parameterType=&quot;Long&quot;&gt;\tSELECT *     FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n我们直接从user表中查询一条数据出来，查询的结果是一个User对象，即：MyBatis会自动帮我们把查询的结果转成User对象。这是怎么做到的？是因为 JavaBean的属性名和数据库表中的字段名能够完全一致地对应上，那么就可以了。\n\n\n别名问题我们习惯于将 JavaBean 中的属性名使用驼峰式命名法（userName），而数据库中的字段使用下划线命名法（user_name）。那么这样不就会导致转换失败了吗？\n对于这种非常常见的场景问题，有三种解决方案：\n\n在 sql 语句中起别名\n&lt;select id=&quot;getById&quot; resultType=&quot;twq.entity.User&quot; parameterType=&quot;Long&quot;&gt;\tSELECT     \tid,    \tuser_name as userName,    \tpassword,    \taddress    FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n这样做的想法是：使数据库中的字段名向JavaBean属性名看齐。由此一来，两者之间的名字又完全对应上了~\n\n使用 mapUnderscoreToCamelCase 属性\n在 MyBatis 的配置文件中，有一个&lt;settings&gt; 节点，该节点中可包含多个 &lt;setting&gt; 节点。&lt;setting&gt; 节点有一个属性叫做mapUnderscoreToCamelCase，该属性表示是否开启自动驼峰命名规则映射，即从经典的数据库列名 A_COLUMN 映射为经典的JavaBean属性名 aColumn 的映射。\n要开启这个属性，只需要在 MyBatis 的配置文件中，添加如下代码：\n&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;\n\n但是使用这种方式，就要求我们的数据库字段命名和JavaBean属性命名都非常遵守命名规范才行，比较严格。但如果你确实是这么遵守的，那么就会变得很方便了~所以这个方案属于是见仁见智，视项目情况而言。\n\n使用 &lt;resultMap&gt; 元素\n这个方法算是别名问题的最终解决方案了。\n我们可以在Mapper中定义 &lt;resultMap&gt; 来解决一些复杂的字段映射问题。\n以 userMapper 为例：\n&lt;resultMap id=&quot;userMap&quot; type=&quot;twq.entity.User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot; javaType=&quot;long&quot; jdbcType=&quot;NUMERIC&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;    &lt;result property=&quot;password&quot; column=&quot;password&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;&lt;/resultMap&gt;\n关于上面的 &lt;resultMap&gt; 需要说明两点：\n\n\n&lt;resultMap&gt; 的id作为它自身的唯一标识符。如果后续想要引用这个 &lt;resultMap&gt; 的时候，就是通过指定这个id名来引用的。\n定义的 type 属性，用于指明这个 &lt;resultMap&gt; 对应的是哪个JavaBean。\n\n在一个 &lt;resultMap&gt; 节点中，存在一个 &lt;id&gt; 节点和多个 &lt;result&gt; 节点。前者是主键字段，后者是其他字段。\nproperty 表示JavaBean中的属性名，column 表示数据库中的字段名，javaType 表示JavaBean中的属性类型，jdbcType 表示数据库中的字段类型。\n\n\n\n\n\n如此定义完毕后，我们就可以很放心且简单地使用 &lt;select&gt; 查询了，只要记得引用这个 &lt;resultMap&gt;，那么别名问题就得到解决了：\n&lt;select id=&quot;getById&quot; resultMap=&quot;userMap&quot; parameterType=&quot;Long&quot;&gt;\tSELECT *     FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n\n\n多条件查询在真正开发中，多条件的查询语句是非常常见的需求。比如我现在需要根据用户名和地址来查找用户，那么我大致可以想象出来：我需要将 userName 和 address 作为方法参数传入，而方法的返回值是一个 User 对象。\n对于多条件参数的情况，可以有以下三种解决方案：\n\n使用 Map 集合对传递的所有参数进行封装\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(Map&lt;String, String&gt; map);\n\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    // 封装参数数据    Map&lt;String, String&gt; map = new HashMap&lt;&gt;(2);    map.put(&quot;addr&quot;, &quot;上海&quot;);    map.put(&quot;username&quot;, &quot;张三&quot;);    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(map);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，将 Map 的数据提取出来（其实就是 key 对应的 value），作为查询参数：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;&lt;/select&gt;\n\n\n\n不过，一般不使用这种方式，因为 Map 的 key 都是硬编码手写的，容易写错；而且以 Map 的方式作为传参也不够直观，可读性不高。\n\n使用 @Param 注解\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(@Param(&quot;username&quot;) String username, @Param(&quot;addr&quot;) String addr);\n\n如此一来，MyBatis 会以 @Param 提供的名称为准。相当于说，@Param 是key，传参是value。\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(&quot;张三&quot;, &quot;上海&quot;);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，将这些数据提取出来，作为查询参数：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;&lt;/select&gt;\n\n这种方式比较常用。因为从Java代码的角度看，这样的可读性高很多，十分直观，也不必像第一种方案，还需要考虑 Map 的key到底是什么。\n\n自定义一个JavaBean对象，封装其中的所有传递参数\n第二种方案其实已经很完美了。但是如果有一个需求，它的查询条件特别多，由此需要的传参也变得特别多。这种情况下，如果还按照第二种方案的写法，那么代码整体看上去就显得十分庞大了，你可能会看到满屏的 @Param 。。。\n其实，MyBatis 是支持用户在传参时直接传入对象的，将需要的数据字段封装起来：\npublic class UserParams &#123;    private String username;    private String addr;    // 你可以想象一下还有十多个属性...    // getter &amp; setter...&#125;\n\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(UserParams params);\n\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    UserParams params = new UserParams();    params.setUsername(&quot;张三&quot;);    params.setAddr(&quot;上海&quot;);    params.setXxxx(obj);    // ...    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(params);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，指定 parameterType 为 UserParams ，然后将其中的属性都提取出来：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot; parameterType=&quot;twq.entity.UserParams&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;    \tand xx_xx = #&#123;xxxx&#125;    \t&lt;!-- and .... --&gt;&lt;/select&gt;\n\n\n\n总的而言，第二种和第三种都是在开发中最常用的传参方式，根据需求的具体情况（参数多or少）自己进行选择。\n\n\n\n\n&lt;insert&gt;主键值回填一般来说，我们在创建表的时候，都会将主键id设置为自增长auto_increment。在这种情况下，当我插入一条新的数据时，是不需要指定id字段的值的（我也不知道id字段的值），传入null即可。但是当我插入成功后，我希望 MyBatis 会回填id字段，赋值给对象的id属性。\n这也是非常常见的一个需求，我需要知道刚刚插入成功的数据的id是多少。\n在 userMappper 中，指定数据库的主键字段、主键生成策略：\n&lt;insert id=&quot;insert&quot; parameterType=&quot;twq.entity.User&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;    INSERT INTO user(user_name,password,address)     VALUES (#&#123;userName&#125;,#&#123;password&#125;,#&#123;address&#125;)&lt;/insert&gt;\n\n\nkeyProperty 属性指定哪个是主键字段\nuseGeneratedKeys 就是告诉 MyBatis，这个主键是否使用了数据库内置的生成策略\n\n编写Java代码：\n@Autowwiredprivate UserMapper userMapper;public void test() &#123;    // 构造一个对象（注意，我没有给id属性赋值，意味着它的id属性是null）    User user = new User();    user.setUsername(&quot;张三&quot;);    user.setPassword(&quot;123456&quot;);    user.setAddress(&quot;上海&quot;);    userMapper.insert(user);    // 插入完成后，MyBatis 会自动回填id属性    // 不再是 null    System.out.println(user.getId());&#125;\n\n\n\n自定义主键值有的时候，我们不想让主键按照自增的规则来变化，而是想有一套自己的规则逻辑。\n解决方案：使用 &lt;selectKey&gt; 来自定义主键的生成策略。\n\n\n作为实例，我们先定义一个主键生成规则：初始时id为1，之后每个新的id自增2。\n在 userMapper 中使用 &lt;selectKey&gt; ：\n&lt;insert id=&quot;insert&quot; parameterType=&quot;twq.entity.User&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;long&quot; order=&quot;BEFORE&quot;&gt;    \tSELECT (ifnull(max(id), -1) + 2) as nextId        FROM user    &lt;/selectKey&gt;    INSERT INTO user(id, user_name, password, address)     VALUES (#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;, #&#123;address&#125;)&lt;/insert&gt;\n\n关于上面的 &lt;selectKey&gt; 需要说明几点：\n\n\n&lt;keyProperty&gt; 属性表示「查询语句的结果」所赋值的目标属性。在这里就是id\n\n&lt;resultType&gt; 属性表示查询结果的返回类型，注意这个类型要和 User 中id的类型保持一致。在这里就是 long\n\n&lt;order&gt; 属性表示「选择主键」和「插入操作」之间的顺序关系。\n\norder=&quot;BEFORE&quot;：在执行插入操作之前先选择主键\norder=&quot;AFTER&quot;：执行完插入操作之后再选择主键\n\n这里需要特别注意：诸如 MySQL 支持自增长类型的数据库，必须设置 order=&quot;AFTER&quot;；诸如 Oracle 取序列的数据库，必须设置 order=&quot;BEFORE&quot;\n\n\n\n\n\n编写Java代码：\n@Autowwiredprivate UserMapper userMapper;public void test() &#123;    // 构造一个对象（注意，我没有给id属性赋值，意味着它的id属性是null）    User user = new User();    user.setUsername(&quot;张三&quot;);    user.setPassword(&quot;123456&quot;);    user.setAddress(&quot;上海&quot;);    userMapper.insert(user);    // 插入完成后，MyBatis 会自动回填id属性    // 不再是 null    System.out.println(user.getId());&#125;\n\n\n\n&lt;delete&gt; &amp; &lt;update&gt;这两者没有什么特别需要说明的地方，要说的基本都在 &lt;select&gt; 和 &lt;insert&gt; 中涉及到了。所以不再赘述了。\n\n\n&lt;resultMap&gt;在前面，已经涉及到了 &lt;resultMap&gt; 的部分内容，包括 &lt;id&gt; 和 &lt;result&gt; 两个节点。但实际上，&lt;resultMap&gt; 还包含着更多的节点：\n&lt;resultMap&gt;    &lt;constructor&gt;        &lt;idArg/&gt;        &lt;arg/&gt;    &lt;/constructor&gt;    &lt;id/&gt;    &lt;result/&gt;    &lt;association property=&quot;&quot;/&gt;    &lt;collection property=&quot;&quot;/&gt;    &lt;discriminator javaType=&quot;&quot;&gt;        &lt;case value=&quot;&quot;&gt;&lt;/case&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;\n\n\n\n接下来，就一个个介绍。\n&lt;constructor&gt;它主要是用来配置构造方法的。\n在默认情况下，MyBatis 是调用实体类的无参构造方法来创建实体类对象，然后再给各个属性进行赋值。但是有些实体类可能并没有无参构造方法（只有显式的有参构造方法），这时候如果不做特殊的配置处理，那么 &lt;resultMap&gt; 在生成实体类的时候就会报错（因为它找不到无参构造方法！！）\n所以解决办法就很显然了：要么给实体类配置一个无参构造方法，要么就是在 &lt;constructor&gt; 中进行相应的配置。前者的实现就没什么好说的了，我们直接看后者是如何配置的：\n&lt;resultMap id=&quot;userResultMap&quot; type=&quot;twq.entity.User&quot;&gt;    &lt;constructor&gt;        &lt;idArg column=&quot;id&quot; javaType=&quot;long&quot;/&gt;        &lt;arg column=&quot;userName&quot; javaType=&quot;string&quot;/&gt;        &lt;arg column=&quot;password&quot; javaType=&quot;string&quot;/&gt;        &lt;arg column=&quot;address&quot; javaType=&quot;string&quot;/&gt;    &lt;/constructor&gt;&lt;/resultMap&gt;\n\n这样，MyBatis在构造实体类对象的时候，就会按照 &lt;constructor&gt; 的配置来对应地给属性赋值了。\n\n\n&lt;association&gt;它主要是用于一对一的联级查询。\n让我们现在开始，忘记之前的 User 实例。假设我现在有两张表：表province存储省份，另一张表province_abbr存储省份的简称。它们之间以一个字段 pid 的方式来连接，表示省份的id。\n这两张表对应的JavaBean如下给出：\npublic class Province &#123;    private Long id;    private String name;    private ProvinceAbbr provinceAbbr;        // getter &amp; setter...&#125;\n\npublic class ProvinceAbbr &#123;    private Long id;    private String name;    // 对应于 Province 中的id    private Long pid;        // getter &amp; setter...&#125;\n\n创建 ProvinceAbbrMapper 接口 &amp; 编写 provinceAbbrMapper.xml：\n@Mapperpublic interface ProvinceAbbrMapper &#123;    ProvinceAbbr getProvinceAbbrByPid(Long id);&#125;\n\n&lt;select id = &quot;getProvinceAbbrByPid&quot; parameterType=&quot;long&quot; resultType=&quot;twq.entity.Province&quot;&gt;    SELECT *     FROM province_abbr    WHERE pid = #&#123;id&#125;&lt;/select&gt;\n\n创建 ProvinceMapper 接口 &amp; 编写 provinceMapper.xml：\n@Mapperpublic interface ProvinceMapper &#123;       List&lt;Province&gt; getAllProvince();&#125;\n\n&lt;resultMap id=&quot;provinceResultMapper&quot; type=&quot;twq.entity.Province&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;association property=&quot;provinceAbbr&quot; column=&quot;id&quot; select=&quot;twq.mapper.ProvinceAbbrMapper.getProvinceAbbrByPid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllProvince&quot; resultMap=&quot;provinceResultMapper&quot;&gt;    SELECT *     FROM province&lt;/select&gt;\n\n对于 &lt;association&gt; 需要说明几点：\n\n\nselect 属性表示一个具体的执行方法，即一个具体的SQL语句，然后将这个执行结果再赋值给这里的 property 指定的属性\ncolumn 属性表示方法传参的属性名。在这里，我应传入省份id作为查询条件\nproperty 属性表示将 select 的执行结果赋值给哪个属性。在这里，应该赋值给 provinceAbbr\n\n\n\n\n&lt;collection&gt;它主要是用于一对多的联级查询。\n还是使用上面的省份例子。不过现在又多了一张城市表city，因为每个省份下包含着很多城市。city表中也有一个pid字段，用于表示这个城市是属于哪个省份的。\ncity表对应的JavaBean如下给出：\npublic class City &#123;    private Long id;    private String name;    private Long pid;        // getter &amp; setter...&#125;\n\n另外，我们还需要去更新一下 Province，增加一个 cities 属性：\npublic class Province &#123;    private Long id;    private String name;    private ProvinceAbbr provinceAbbr;    private List&lt;City&gt; cities;        // getter &amp; setter...&#125;\n\n创建 CityMapper 接口 &amp; 编写 cityMapper.xml：\n@Mapperpublic interface CityMapper &#123;    List&lt;City&gt; findCitiesByPid(Long id);&#125;\n\n&lt;select id=&quot;findCitiesByPid&quot; parameterType=&quot;long&quot; resultType=&quot;twq.entity.City&quot;&gt;    SELECT *     FROM city     WHERE pid=#&#123;id&#125;&lt;/select&gt;\n\n更新 provinceMapper.xml：\n&lt;resultMap id=&quot;provinceResultMapper&quot; type=&quot;twq.entity.Province&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;association property=&quot;provinceAbbr&quot; column=&quot;id&quot; select=&quot;twq.mapper.ProvinceAbbrMapper.getProvinceAbbrByPid&quot;/&gt;    &lt;collection property=&quot;cities&quot; column=&quot;id&quot; select=&quot;twq.mapper.CityMapper.findCitiesByPid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllProvince&quot; resultMap=&quot;provinceResultMapper&quot;&gt;    SELECT *     FROM province&lt;/select&gt;\n\n&lt;collection&gt; 中的各个属性的含义和 &lt;association&gt; 是一样的，所以就不再说明了。\n","tags":["项目"]},{"title":"「多线程」时间管理大师指南","url":"/2022/05/17/%E3%80%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8D%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%E7%A8%8B%E5%BA%8F%E6%8C%87%E5%8D%97/","content":"线程线程的几种状态？\n新建 New\n就绪 Runnable\n运行 Running\n阻塞 Blocked\nI&#x2F;O ：阻塞态，仅释放CPU资源，但不会释放占有着的锁。如 sleep()\nWaiting ：等待态，会释放CPU资源和占有着的锁。如 wait()\nTimed Waiting ：带有超时的等待态\n\n\n结束 Terminated\n\n\n\n线程和进程的区别是什么？\n首先，可以从宏观的角度看待它们的关系：一个程序至少有一个进程，一个进程至少有一个线程。\n进程是操作系统进行资源分配的最小单元，每个进程都有自己独立的内存空间。进程与进程之间是不共享资源的。如果需要，那么就要使用通信技术（socket、channel）。\n线程是操作系统进行资源调度的最小单元。除了线程自己的函数堆栈等，线程与线程之间是共享资源的（这也是为什么会存在线程安全这一问题）。\n打个比喻：进程是水杯，线程是水杯里的水。实际有用的是水而不是水杯，但是如果没有水杯这个容器来装水也是不行的。\n\n进程可以看作是重量级的线程。在多任务处理机的环境下，如果直接使用进程作为调度单元，那么在资源切换时的开销是比较大的。为了提高执行效率，所以引入了线程来取代进程的资源调度功能。\n\n\n\n\n上下文切换是什么？因为多线程是共用计算机上的CPU资源的，并且在一般情况下，线程数都是大于CPU核心数的。为了让所有线程都有执行的机会，所以需要进行线程之间的调度切换。这种切换就是上下文切换。在切换前，需要保存CPU的状态；在切换回来后，又需要恢复CPU的状态，使得线程能够正确地从中断处恢复执行。\n在Java中，线程调度采用的是抢占式的方式。一个线程的时间片到后，操作系统会根据线程优先级、线程饥饿情况、CPU空闲率等多方面因素，选出下一个线程，并分配时间片给它。\n可以通过 setPriority() 来设置线程的优先级。不过，你不能指望靠它来保证，因为最终权还是在底层的操作系统。但是，如果不是特别需求，就不要改动线程的优先级，因为这可能会因为设置不当，造成线程饥饿问题（当前线程被一个高优先级的线程吞噬掉了所有的CPU时间）。\n\n\n什么是线程饥饿？死锁是什么？线程饥饿指的是：一个线程因为某种原因无法获得所需资源，导致一直无法执行下去。\n死锁指的是：两个及以上的线程在执行时，因互相需要对方的资源，却又不肯先释放自己持有的资源，导致全都永远等待在原地。\n（听起来好像，又好像没有区别😂）\n死锁和饥饿的相同点是：二者都是因为资源的竞争引起的问题。\n死锁和饥饿的不同点是：\n\n在死锁中，资源的占有方和资源的拥有方互相请求对方的资源；在饥饿中，当前线程只是迟迟得不到所需资源，但是并不在乎这个资源是谁给的！\n死锁一定涉及多个线程，而饥饿可能只有一个线程。\n当饥饿发生时，除了饥饿线程它自身得不到执行机会，其他线程都还是正常执行的；当死锁发生时，可能最终会使整个系统都陷入死锁并崩溃。\n\n这样听起来，好像死锁更严重些。那么避免死锁有哪些方案呢？\n\n确定好加锁的顺序，比如按照哈希值的大小来决定顺序\n尽可能缩减加锁的范围，只在需要操作共享变量的时候再加锁\n使用带有超时等待时间的锁（如ReentrantLock就可以指定超时时间），一段时间内申请不到这个锁的权限，就直接释放掉\n\n\n\n子线程运行，为什么调用的是start()而不是run()？new Thread()，线程进入了新建状态；调用start()，线程进入了就绪状态；当分配得到CPU的时间片以后，就会执行具体的run()方法，进入运行状态。\n也就是说，start()会执行线程的相应准备工作，然后自动执行run()方法中的内容。这才是真正的多线程工作！\n如果直接在主线程中调用run()，那么就相当于调用了一个普通的方法，这一切还是在主线程下工作的，也就没有达到多线程的效果。\n总而言之，调用start()会使线程启动，进入就绪状态。而如果直接调用run()，这会被认为只是一个名为run的普通方法，仍旧是在主线程下工作的。\n\n\nCallable 和 Future 的区别？Callable 接口类似于 Runnable（从命名风格也可以看得出来），不过 Runnable 不会返回执行结果，也无法抛出返回结果的异常。但是 Callable 就弥补了这一缺陷，可以认为是带有回调功能的 Runnable ：能够返回异步执行的结果，然后由 Future 接收到。\n\n\n线程之间如何进行通信？\n使用 Object 类中提供的 wait() &amp; notify()/notifyAll() 、park() &amp; unpark() 机制\n使用 concurrent 包下的同步工具类，如 CountDownLatch 、CyclicBarrier 。\n\n\n\n为什么要把 wait()、notify() 这种方法定义在 Object 类中？\nJava 中的每个对象都有一个对应的 Monitor 对象。当该对象调用了 wait()、notify() 这些方法时，其实就是在向 Monitor 对象传达信息：等待对象的锁 &#x2F; 通知其他线程对象的 Monitor 是可用的。\n在 Java 的线程中，并没有提供线程同步的方法。为了使得每个类都具有线程间通信的能力，所以给每个类都应该提供一个类似 wait() 、 notify()/notifyAll() 的方法。而 Object 作为所有类的父类，将这样的方法直接放在 Object 中也是十分合适的。\n\n\n\n保证线程安全的方案？首先，先讲讲什么叫做线程安全。\n在我认为，线程安全就是多个线程同时执行某件事情，最终的结果是否能够达到预期的效果。就拿最经典的多线程入门案例《卖票》来说，如果我在多线程模式下运行，能否保证不超卖？\n\n\n然后再说回来，如何解决线程安全问题呢？一般有如下方案：\n\n使用 synchronized 关键字\n\n能否通过保证操作的原子性来实现线程安全？使用atomic包\n\n能否通过保证操作的可见性来实现线程安全？使用 volatile 关键字\n\n能否通过对线程的控制来实现线程安全？使用CountDownLatch&#x2F;Semaphore\n\n如果需要对集合保证线程安全，可以使用concurrent包\n\n使用线程的本地局部变量 ThreadLocal\n对于 ThreadLocal 的具体介绍，可以看这篇文章：「Java」ThreadLocal笔记\n\n将对象设置为不可变 (即：对象一旦被创建，就不能再改变引用了)\n比如：基本类型的包装类都是不可变类。另外，String类型也是不可变的，我之前有写过关于String是不可变类的分析：「String」不可变类的原因！\n\n\n\n\n线程池为什么要用线程池？直接 new Thread() 不好吗？\n创建线程对象是一个开销较大的操作，无论是对CPU还是对内存占用。所以，如果一个任务就开辟一个新线程，性价比实在是太低了。\n\n通过 new Thread() 得到的线程是不易管理的（一般被称为野线程），甚至可以无限制的创建！如此一来，如果使用者使用不慎，可能就导致整个操作系统瘫痪了……🙃\n\n通过 new Thread() 得到的线程也不易于扩展。比如，想要定时执行、定期执行的话，都是不容易实现的。\n\n\n\n\n因此，引入了一个名为线程池的思想，完美解决了上述缺点。\n\n复用已创建好的那些线程，从而降低了资源消耗，并且便于管理\n可以很方便地进行功能扩展，达到定时执行等效果\n\n不过，如果阅读过阿里巴巴开发手册就会发现，不建议使用 Executors 来创建线程。主要原因是：用这样的方式来创建线程，使用者对于这个默认线程池的规则是不够了解的，这就有可能导致使用不当。\n所以，一般建议使用 ThreadPoolExecutor 来创建线程池，并由使用者来设置线程池的一些核心参数，保证使用者对于这个自定义线程池的规则是了解的。\n\n\n常用的线程池\nnewCachedThreadPool()：创建一个可缓存线程池，如果线程池的大小超过实际需要，在超时时间后会回收空闲线程。当任务数增加时，又可以动态地添加新线程来处理任务。\nnewFixedThreadPool()：创建一个大小固定的线程池。每次提交一个任务就会创建一个线程，直至到达线程池的最大大小。超出的线程会在阻塞队列中等待。\nnewSingleThreadExecutor()：创建一个单线程化的线程池，使用唯一的工作线程来执行所有任务。可以保证所有任务都是按照顺序来执行的。\nnewScheduledThreadPool()：创建一个大小固定的线程池。支持定时及周期性任务执行。\n\n\n\n解读一下线程池的7大核心参数？\ncorePoolSize : 核心线程数\nmaximumPoolSize : 最大线程数 (核心线程数+救急线程数)\nkeepAliveTime : 空闲的救急线程的最大存活时间\nTimeUnit : keepAliveTime 的时间单位\nworkQueue : 阻塞队列，用于存放那些待执行的任务\nthreadFactory : 创建线程池中的工作线程的线程工厂 (一般都是默认即可)\nrejectedHandler : 拒绝策略。当线程池中的阻塞队列已满，且线程数已达到最大线程数时，执行拒绝策略。\nAbortPolicy : 拒绝新任务并抛出异常\nDiscardPolicy : 拒绝新任务，但不抛出异常\nCallerRunsPolicy : 使用当前调用的线程来执行此任务 (相当于为了让任务不失败，于是让它插队)\nDiscardOldestPolicy : 抛弃阻塞队列头部 (最旧) 的一个任务，并执行当前任务\n\n\n\n\n\n对于阻塞队列的使用，需要进行一点说明：\n\n如果使用的是 LinkedBlockingQueue 等无界队列，那么可以无限地向线程池中添加任务 (因为阻塞队列不会满) 而不会触发拒绝策略。并且，也不会触发救急线程。所以，相当于 maximumPoolSize, keepAliveTime, TimeUnit, rejectedHandler 都是无意义的参数。\n如果使用的是 ArrayBlockingQueue 等有界队列，那么如果阻塞队列已满，就会触发救急线程。如果救急线程也达到了上限，那么再有新任务时就会触发拒绝策略。\n\n\n\n线程池的执行流程？\n当线程数小于 corePoolSize 时，使用核心线程来执行任务\n当线程数大于 corePoolSize 时，将多余的任务放入阻塞队列\n当阻塞队列已满时，启动救急线程来执行\n当阻塞队列已满，且线程数已达到 maximumPoolSize 时，执行拒绝策略\n当阻塞队列不再满时，已创建的那些救急线程就进入空闲状态。如果它们的空闲时间超过 keepAliveTime ，就会回收这些救急线程\n\n\n\nsubmit() 和 execute() 的区别？这两者都是用于向线程池提交任务的。\n区别在于：\n\nexecute() 没有返回值\nsubmit() 返回值是一个 Future 对象，从而可以得到异步执行的结果\n\n\n\nsynchronized 关键字synchronized 的作用\n如果 synchronized 修饰的是一个实例方法，则上锁的是调用该方法的对象实例\n如果 synchronized 修饰的是一个静态方法，则上锁的是所在类的Class实例\n如果 synchronized 修饰的是一个代码块，则上锁的是传入 synchronized 括号内的对象实例\n\n请知道一条原则：同步块的作用范围越小越好。\n\n\n关于 Mark Word 和 Monitor 对象\n无论 synchronized 修饰的是什么，对应的锁都是一个实例对象。\n一个对象，是由三部分组成的：对象头、对象实际内容、对齐填充字段。synchronized 的原理，就在于对象头之中的 Mark Word 部分。这部分就负责记录对象关于锁的信息。\n\n另外，每个对象都会有一个 Monitor 对象，存储着当前持有该 (对象) 锁的线程，并维护一个阻塞等待该 (对象) 锁的等待队列。\n\n\n\n\n锁的优化策略在JDK1.6之前，锁的操作都是重量级的。这个过程依赖的是底层操作系统的 mutex 指令，需要在用户态与内核态之间切换，所以性能损耗比较严重。\n在JDK1.6之后，引入了偏向锁、轻量级锁的概念，它们是在JVM层面的规定，所以就不依赖于底层的操作系统，性能得到大幅提升。\n总体流程是：无锁 &#x3D;&#x3D;&gt;  偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁。并且，锁只有升级，不存在降级。但是从使用层面看，至始至终都是关键字 synchronized，即：这种优化是内部的，对于使用者而言是无感知的。\n引入了偏向锁和轻量级锁这两个概念，就是为了能够尽可能地提高并发执行时的效率问题。\n\n偏向锁\nJVM认为在同一时间，只会有一个线程来执行同步块中的代码，即：这是一个没有竞争的环境。\n所以直接在 Mark Word 中记录该线程。如果一个线程想要获得锁，就直接比对线程ID与 Mark Word 中存放的是否一致，一致就可以直接获得这个锁；否则，用CAS来尝试修改 Mark Word，将记录改为当前线程ID。\n如果CAS修改成功，那么线程仍旧可以获得这个锁；否则，说明当前环境是存在竞争的，于是升级为轻量级锁。\n\n轻量级锁\n当前线程会在栈帧下创建 Lock Record，把 Mark Word 的信息都拷贝进去。如果一个线程想要获得锁，先用CAS来尝试将 Mark Word 信息修改为该线程的 Lock Record。\n如果CAS修改成功，那么线程就获取到了这个锁 (轻量级) ；否则，进行自旋重试。当自旋一定次数后仍不能获得锁，就升级为重量级锁。\n\n重量级锁\n由monitor对象直接存储持有着锁的线程的id，并设置 Mark Word 中的 monitor对象地址\n\n\n\n\n总结：\n\n只有一个线程进入临界区：偏向锁\n多个线程交替进入临界区：轻量级锁\n多个线程同时进入临界区：重量级锁\n\n\n\n关于 java.util.concurrent乐观锁和悲观锁是如何理解的？\n乐观锁：非常乐观，认为每次拿到的数据都没有被人修改过，所以不会上锁。\n在进行更新的时候，使用的是CAS算法：先判断当前值是否是预期值，如果是，则可以进行写操作写入新值；否则，被告知这次竞争失败，然后进行再次尝试，直到成功。\n乐观锁的缺点是：\n\nABA 问题\n线程1读取了某变量的值是A 。此时线程2也读取了该变量，并且线程2将它改为了B ，后又改回为A 。\n然后线程1进行CAS操作，发现当前值与预期值一致，均为A ，于是放心地写入了新值。\n以上过程，线程1的CAS操作是成功的，但这是有潜在隐患的。\n从 JDK1.5 开始，提供了一个名为 AtomicStampedReference 的类来解决ABA问题，即增加了一个比对元素：版本号。每次操作后都会更新这个版本号。这样，即使是同一个值，如果版本号不一致，也被认为是CAS失败。\n\n如果资源竞争十分激烈，那么CAS自旋的概率会很高，从而导致大多数时间都是在浪费CPU资源，效率反而不如 synchronized 。\n\n只能保证对于一个变量的原子操作。如果需要保证对于多个变量的原子操作，那么就需要用锁了。\n\n\n\n悲观锁：非常悲观，总是做最坏的打算，认为每次拿到的数据都是被人修改过了的，所以每次在拿到数据时都会上锁，这样其他线程就拿不到了。\nJava 的同步关键字 synchronized 就是悲观锁的。此外，传统的关系型数据库 (例如MySQL) 里面的行锁、表锁、读锁、写锁等，用到的也都是悲观锁的机制。\n悲观锁是足够安全的，但是缺点也很明显：每次操作都要上锁，结束后再释放锁，比较耗时。\n\n\n在大多数情况下 (竞争不是特别激烈) ，乐观锁的性能是远远好于悲观锁的。\n\n\nLock 接口是什么？对比传统的同步，有什么优势？Lock 接口是同步的扩展，使用起来更加**灵活 **。典型的一个实现类是 ReentrantLock 。\n\n支持公平&#x2F;非公平的模式选择 (出于性能考虑，一般都是默认非公平模式)\n允许线程在等待锁时被中断\n允许让线程去尝试获得锁，如果无法获得，可以选择立即返回不再等待或是等待一段时间 (带有超时时间)\n配合条件变量 Condition 来使用，达到 wait&#x2F;notify 的效果，并且是支持中断、超时的\n\n不过，需要注意的是：使用 synchronized 无需考虑释放锁的操作，因为这是自动的；而 Lock 就必须要求使用者手动来释放锁资源。因此，最规范的写法就是在 finally 块中进行 unlock() 释放操作。\n\n\n公平锁和非公平锁的区别是什么？简单来说，公平锁模式是讲究先来后到的顺序的；非公平锁模式是谁准备好了就谁来。\n公平锁：在竞争环境下，先到达临界区的线程一定比后到达临界区的线程更早地获得锁。\n非公平锁：在竞争环境下，先到达临界区的线程未必比后到达临界区的线程更早地获得锁。\n所以，决定它们的因素就是：如果一个线程到达了临界区，它是否会直接尝试获得锁 (非公平) ，还是会直接进入等待队列 (公平) 。\n\n\n并发容器类\nCopyOnWriteArrayList (性能较差的同步容器是 Vector)\n主要特点是：读写分离。\n\n实际的写操作发生在复制的数组上，而读操作还是在原始数组中进行，从而实现读写分离，互不影响。\n在写操作时需要加锁，防止并发写入时导致写入数据丢失。\n在写操作结束后，把原始数组的引用指向新的复制数组。\n\n缺点是：\n\n由于每次写操作都会复制出一个新的数组，所以是比较耗费内存的。\n只能保证最终一致性，无法保证实时一致性。\n\n我们可以从中学到的线程安全解决思路是：通过另辟空间，来解决并发问题。\n\nConcurrentHashMap (性能较差的同步容器是 HashTable)\n底层数据结构与普通的 HashMap 一样，同为数组+链表&#x2F;红黑树。\n\n在 put() 写操作时需要加锁，不过使用的是 CAS算法 (在JDK8之前，使用的是分段锁的方式)\n在 get() 读操作时不加锁，value属性通过 volatile 关键字进行修饰，保证了内存可见性，即每次 get() 得到的都是最新值\n\n\n\n\n\n同步工具类\nCountDownLatch\n在创建时传入一个参数 new CountDownLatch(int initial) 作为计数次数。\n其他线程每调用一次 countDown() 方法，计数器减1。\n当计数器被减为0时，主线程从 latch.await() 处重新被唤醒，然后继续执行后续代码。\n\nCyclicBarrier\n和 CountDownLatch 的作用一样，只不过 CountDownLatch 只能使用一次，使用之后就会失效，而 CyclicBarrier 可以反复使用。\n\nSemaphore\n在不超过设定上限的线程数的情况下，允许多个线程并行执行。主要用于限流之类的操作，限制某段代码块的并发数。打个比喻：Semaphore 就好比是一个停车场，允许同时停放多辆车辆，但也总有一个上限。\n如果 Semaphore 的构造函数中传入的参数是 1 ，就相当于一个 synchronized 了。\n\n\n\n\nAQS是什么？全称是 AbstractQueuedSynchronizer 。作为一个抽象类，相当于是很多同步容器的框架模板，其中制定了很多用于保证线程安全的基本规则。\n常用的实现类有 ReentrantLock, Semaphore, FutureTask 等。\n\n\nAQS的原理底层是使用一个双向链表来维护一个FIFO的等待队列，还有一个 state 的状态变量。\n队列中存储的实体是 Node 节点，记录了当前的状态值、同步模式 (独占 &#x2F; 共享) 、前驱节点和后继节点。\n总体流程是：把需要等待的线程以 Node 节点的形式加入到等待队列中，用 state 变量来维护当前锁的状态。\n当调用了 lock() 方法时：\n\n使用CAS来尝试获得锁。如果成功，那么就可以执行同步块中的代码；\n\n否则，调用 acquire() 方法，判断 state 是否为0。如果等于0，说明没有其他线程持有这把锁，那么就再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n\n否则，说明有线程正在持有着这把锁。于是再判断当前线程是否持有着锁，如果是，那么更新 state 的值加1 (这里正是可重入的体现) ，然后就可以执行同步块中的代码；\n\n否则，只能将当前线程加入等待队列中，然后将自己 park() 挂起，等待后续被唤醒后再继续进行CAS尝试……直至成功，然后执行同步块中的代码。\n在加入等待队列的过程中，其实还有一些细节：\n\n节点入队后，会判断前驱节点是否为头节点。如果是头节点，那么就可以再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n否则，会把前驱节点的状态设置为 SIGNAL (-1) ，用以表示后续节点需要被唤醒，而这个任务就交给了前驱节点。\n\n\n\n当调用了 unlock() 方法时，就非常简单了：把 state 置0，然后唤醒等待队列中第一个需要被唤醒的节点 (节点的 state 小于0) ，然后这个节点就会进行CAS尝试来获得锁。\n\n\nAQS的同步方式是什么？AQS支持两种同步方式：独占式和共享式。\n独占式，锁只会被一个线程持有。如 ReentrantLock\n共享式，多个线程可以同时执行。如 Semaphore, CountDownLatch\n\n\nvolatile 关键字volatile 的作用是什么？\nvolatile 可以保证内存可见性。被 volatile 修饰的变量在进行写操作后，其他线程能马上读到最新值。\n简单地说，就是在对一个 volatile 变量进行写操作前，JMM会插入一个写屏障，保证所有线程都可以马上看见这个新值；在对一个 volatile 变量进行读操作前，JMM会插入一个读屏障，保证任何数据的更新对所有线程都是可见的。\n\nvolatile 可以保证不会发生指令重排序的问题。最典型的使用场景就是懒汉式的DCL单例模式。\n\n\nclass Singleton &#123;  /** 这里一定要使用 volatile 关键字来修饰单例实例，以防止指令重排序导致的线程不安全问题 */  public static volatile Singleton singleton;    /** 构造器使用 private 修饰，对外部进行屏蔽 */  private Singleton() &#123;&#125;    /** 对外暴露的唯一公开静态方法，以此提供单例实例。这里使用 volatile+DCL 来保证线程安全 */  public static Singleton getInstance() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n​\t线程安全的单例模式还可以是静态内部类；亦或是直接使用饿汉式，在类加载时就创建，由jvm保证了线程安全性。\n​\t不过就不展开了，毕竟本文的主要内容不是设计模式 :-)\n\n与CAS操作结合，保证线程安全性。\n\n\n\n为什么会发生指令重排序？这是出于性能最大化考虑，CPU常常会对指令进行重排序。\n当然，前提是不会改变程序的运行结果 🤣 否则编程就成为一个玄学问题了，能否运行正确全靠人品？？\n\n\n一些编写多线程的最佳实践\n不要自己手动创建线程对象，而是使用线程池来管理线程对象，达到资源复用的效果。\n给线程命名，并开启打印线程名的功能。这样有助于进行调试。\n尽可能最小化临界区的范围，而不是无脑地将整个方法进行同步。\n如果可以，使用 volatile 来代替 synchronized。\n当需要进行线程间通信时，使用 concurrent 包下的那些同步工具类（如 CountDownLatch, Semaphore），而不是使用 wait() &amp; notify()。\n当需要使用线程安全的容器集合时，使用 concurrent 包下的那些并发容器类，而不是使用 util 包下的普通容器类再进行 synchronized 同步。\n\n","tags":["Java","多线程"]},{"title":"「环境搭建」 步骤总结","url":"/2022/05/30/%E3%80%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%8D%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93/","content":"jdk安装阶段官网安装地址：Java Downloads | Oracle\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段\n配置环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 JAVA_HOME 的变量名，其值为 jdk 的安装目录路径。\n这里是一个示例：\n\n在系统变量的 Path 变量中，添加一条记录 %JAVA_HOME%\\bin。\n\n\n\nMac\n\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n在 .bash_profile 文件中进行编辑，配置 jdk 环境变量\nexport JAVA_HOME=your/path/to/jdkexport PATH=$JAVA_HOME/bin:$PATH:.export CLASS_PATH=$JAVA_HOME/lib# 使配置文件立即生效source ~/.bash_profile\n\n\n\n\n检验配置是否成功\n现在，让我们在终端输入 java -version 来测试是否一切都正常。如果能正确显示版本号，那么就配置成功了~ 否则，就需要重新检查 JAVA_HOME 和 Path 中的路径配置是否有问题。\n\n\n\n\n其实还有一个叫做 classpath 的配置项，不过官方表示：jdk1.5以后就不用配置它了，所以这里也不再赘述。\n\n\nidea安装阶段官网安装地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段总的来说，这篇文章已经很齐全了，标记一下：Idea安装与配置详解\n下面，说几个重点部分。\n\n导入 Settings 配置\nFile -&gt; Manage IDE Settings -&gt; Import Settings\n\n设置 Font 字体\nFont: JetBrains Mono, Size: 20.0, Line height: 1.35, Fallback font: SimHei\n\n导入 Color Scheme 配色方案（现在有了云同步功能，只要登录自己的账号就行了，所以这一步基本上不再需要手动导入了）\n\n\n\n\nMySQL安装阶段官网安装地址：MySQL :: Download MySQL Community Server\n\n\n配置阶段\nWindows: 超级详细的mysql数据库安装指南\nMac: mac下mysql的安装步骤\n\n\n\nRedis安装阶段\nWindows\nRedis官方没有提供Windows版本的Redis。\n但微软开发和维护着Windows64版本的Redis，可以在GitHub上进行下载：microsoftarchive&#x2F;redis\n\n下载 .zip 的压缩包文件，并解压至任意目录\n启动服务器程序 redis-server.exe，并保持窗口开启\n启动客户端程序 redis-cli.exe，然后执行 ping 命令。如果显示 PONG，那么说明连接成功。\n\n\nMac\n官网安装地址：Download | Redis\n\n下载压缩包文件，并解压至任意目录\n\n在Redis安装目录下，打开终端，并进行编译测试：\nsudo make test\n\n如果一切顺利，那么可以开始执行Redis的安装：\nsudo make install\n\n如果安装成功，则会有相应提示 :)\n\n\n\n\n\n\n配置阶段\n配置系统环境变量\n\nWindows: Redis下载安装与配置(windows)\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，在系统变量的 Path 变量中，添加一条记录，可以直接输入Redis的安装目录。 \n这里是一个示例：E:\\develop\\Redis-x64-3.2.100\n\n在Redis的安装目录下，打开终端窗口，输入以下命令：\nredis-server.exe --service-install redis.windows.conf --loglevel verbose\n\n提示 “Redis sucessfully installed as a service.” ，则表明Redis服务安装成功！\n如果后续需要卸载Redis服务，那么输入以下命令：\nredis-server --service-uninstall\n\n提示 “Redis service sucessfully uninstalled.” ，则表明Redis服务卸载成功！\n\n\n\nMac: Mac上redis下载安装与配置详细版\n\n打开终端并执行以下命令：\n# 在redis目录下创建 bin、etc、db 这三个目录sudo mkdir /usr/local/redis-6.2.2/binsudo mkdir /usr/local/redis-6.2.2/etcsudo mkdir /usr/local/redis-6.2.2/db\n\n把 /usr/local/redis/src 目录下的 mkreleasehdr.sh, redis-benchmark, redis-check-rdb, redis-cli, redis-server 拷贝到 bin 目录：\ncp /usr/local/redis-6.2.2/src/mkreleasehdr.sh /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-benchmark /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-check-rdb /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-cli /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-server /usr/local/redis-6.2.2/bin\n\n拷贝 redis.conf 到 /usr/local/redis/etc 下：\ncp /usr/local/redis-6.2.2/redis.conf /usr/local/redis-6.2.2/etc\n\n编辑 etc 目录下的 redis.conf 配置文件：\nsudo vim /usr/local/redis-6.2.2/etc/redis.conf\n\n并在文件中添加如下代码：\n# 修改为守护模式daemonize yes# 设置进程锁文件pidfile  /Users/xxx/Desktop/Py/redis/redis.pid # 根据自己的路径进行相关配置# 端口port 6379# 客户端超时时间timeout 300# 日志级别loglevel debug# 日志文件位置logfile /Users/xxx/Desktop/Py/redis/log-redis.log # 根据自己的路径进行相关配置# 设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库iddatabases 16## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合# save# Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000# 指定存储至本地数据库时是否压缩数据，默认为yes# 如果为了节省CPU时间，可以改为no，但会导致数据库文件十分大rdbcompression yes# 指定本地数据库文件名dbfilename dump.rdb# 指定本地数据库路径dir  /Users/xxx/Desktop/Py/redis/db/ # 根据自己的路径进行相关配置# 指定是否在每次更新操作后进行日志记录# Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。appendonly no# 指定更新日志条件，共有3个可选值：# no：表示等操作系统进行数据缓存同步到磁盘（快）# always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）# everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec\n\n启动客户端程序 ./redis-cli，然后执行 ping 命令。如果显示 PONG，那么说明连接成功！\n\n\n\n\n\n\n\n\nMaven安装阶段官网安装地址：Maven – Download Apache Maven\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段maven的使用是在jdk的基础上，因此，请先确保自己电脑已经有了jdk环境。\n\n配置环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 MAVEN_HOME 的变量名，其值为 maven 的安装目录路径。\n这里是一个示例：\n\n在系统变量的 Path 变量中，添加一条记录 %MAVEN_HOME%\\bin。\n\n\n\nMac\n\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n在 .bash_profile 文件中进行编辑，配置 jdk 环境变量\nexport MAVEN_HOME=your/path/to/mavenexport PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH:.# 使配置文件立即生效source ~/.bash_profile\n\n\n\n\n检验配置是否成功\n打开终端，输入命令 mvn -v 如果能正确显示版本号，那么就配置成功了~\n\n配置本地仓库的存储路径\n\n在maven的安装目录下，创建一个文件夹，用于作为仓库。（一般将这个文件夹起名为 repository）\n\n在核心配置文件 conf/settings.xml 中，将本地仓库路径设置为对应路径即可。\n这里是一个示例：&lt;localRepository&gt;E:\\develop\\apache-maven-3.8.3\\repository&lt;/localRepository&gt;\n\n\n\n配置中央仓库地址\n在mirrors节点添加新的mirror子节点，以下内容截取自我自己的配置文件：\n   &lt;mirrors&gt;     &lt;mirror&gt;       &lt;id&gt;central&lt;/id&gt;       &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;       &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;     &lt;!--  阿里仓库  --&gt;     &lt;mirror&gt;       &lt;id&gt;alimaven&lt;/id&gt;       &lt;name&gt;aliyun maven&lt;/name&gt;       &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;repo2&lt;/id&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       &lt;name&gt;Human Readable Name for this Mirror&lt;/name&gt;       &lt;url&gt;https://repo2.maven.org/maven2/&lt;/url&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;jboss-public-repository-group&lt;/id&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       &lt;name&gt;JBoss Public Repository Group&lt;/name&gt;       &lt;url&gt;https://repository.jboss.org/nexus/content/groups/public&lt;/url&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;google-maven-central&lt;/id&gt;       &lt;name&gt;Google Maven Central&lt;/name&gt;       &lt;url&gt;https://maven-central.storage.googleapis.com&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;   &lt;/mirrors&gt;5. 与 Idea 集成   关闭并重新打开 Idea ，找到 `Preferences -&gt; Build, Execution, Deployment -&gt; Maven`，自定义maven路径和配置文件路径。&lt;br&gt;# Git## 安装阶段官网安装地址：[Git (git-scm.com)](http://book.git-scm.com/)在安装过程中有很多可选项，当然你可以傻瓜式的不断next，但如果想要自定义，可以参考文章：[Git安装包教程（详解Git安装过程）](https://www.cnblogs.com/xueweisuoyong/p/11914045.html)。&lt;br&gt;## 配置阶段1. Git 提供了一个叫做 git config 的命令，专门用来配置或读取相应的工作环境变量。   git config 后面可以跟随一个参数，用于表示该配置变量的生效范围：   - `--system` 对系统上每一个用户及他们的仓库都生效   - `--global` 只针对当前用户的每个仓库生效   - `--local` 只对当前的仓库生效   并且，以上排列是按照优先级进行升序排序的。每一个级别会覆盖上一级别的配置，比如 `--global` 的配置变量会覆盖 `--system` 中的配置变量。2. 安装完 Git 之后，要做的第一件事就是设置你自己的用户名和邮件地址。   这一点很重要，因为每一个 Git 提交记录中都会显示这些信息，用于标识和区分代码的提交者。   由于这些都是与当前用户相关联的，因此将生效范围设置为 `--global` 比较合适：   ```bash   git config --global user.name &quot;你的名字&quot;   git config --global user.email &quot;你的邮箱@xxx.com&quot;\n\n查看配置信息\n如果你想查看之前配置过的东西，可以使用 git config --list 命令来列出所有 Git 可以找到的配置项。\n如果你是有针对性的查找某一项配置，也可以直接使用 git config &lt;key&gt; ，如 git config user.name 。\n\n配置SSH公钥\n\n生成一个密钥对。在用户盘的 .ssh 文件夹中，打开 Git Bash，然后输入：\nssh-keygen\n\n这时，.ssh文件夹中会生成两个密钥文件 id_rsa 和 id_rsa.pub。\n以文本编辑器（如记事本）的方式打开 id_rsa.pub，将文件内容全选并复制到 GitHub 上。\n\n登陆 GitHub，点击右上角头像，选择Settings，选择左侧菜单栏中的 SSH and GPG keys，再点击 New SSH key，将前面复制的内容粘贴在这里。\n\n回到 Git Bash 界面，测试是否配置成功：\nssh -T git@github.com\n\n如果提示 Hi xxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. ，那么就证明成功了。\n\n\n\n配置远程仓库\n如何将本地的代码文件提交至远端服务器？那么就要将你的本地仓库与远程仓库建立一个连接，通过以下命令：\ngit remote add &lt;name&gt; &lt;git_address&gt;\n\n其中，一般都将名字设置为 origin ，这相当于是一种默认规范了，即：\ngit remote add origin username@host:/path/to/repository\n\n然后，就可以向这个远程仓库发送文件啦！这里指定一个master分支：\ngit push -u origin master\n\n\n\n如果想查看已经添加成功的远程仓库，可以使用：\ngit remote\n\n与 Idea 集成\n路径设置：打开 File -&gt; Settings -&gt; Version Control -&gt; Git（不过一般都能被自动识别）\nTerminal设置：打开 File -&gt; Settings -&gt; Tools -&gt; Terminal，将其中的 Shell path 改为 Git Bash 的路径即可。\n\n\n\n\nnode.js安装阶段官网安装地址：下载 | Node.js (nodejs.org)\n安装阶段没有太多需要额外说明的。\n新版的Node.js已经集成了npm，所以就不需要再去特意安装npm了。安装完成后，打开终端窗口，执行以下命令：\n# 查看node版本node -v# 查看npm版本npm -v\n\n如果能正确显示版本号，那么就已经安装成功了！\n\n\n配置阶段\n配置npm在全局模块的安装路径地址和缓存路径地址\n\nWindows\n在nodejs安装目录下，新建两个文件夹，分别用于作为全局模块的安装路径地址和缓存路径地址，并使用命令行修改npm的相关配置。\n以下是一个示例：\n新建文件夹 node_global 和 node_cache，然后打开终端输入以下命令：\nnpm config set prefix &quot;E:\\develop\\node.js\\node_global&quot;npm config set cache &quot;E:\\develop\\node.js\\node_cache&quot;\n\n\n修改系统环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 NODE_PATH 的变量名，其值为 node_modules 文件夹\n这里是一个示例：\n\n高级系统设置 -&gt; 环境变量 -&gt; 用户变量，在 Path 变量中新建一条记录，其值为 node_global 文件夹\n这里是一个示例：\n\n\n\nMac\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n由于MacOs环境下的nodejs和npm可执行文件都在 &#x2F;usr&#x2F;local&#x2F;bin 目录下，所以加上这样一项就行了：\nexport PATH=/usr/local/bin/\n\n之后，再重新打开终端，并输入 node ，就会进入node环境。按两次 control+c 可退出node环境。\n\n\n\n\n","tags":["环境搭建"]},{"title":"「链表」链表题总结","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"链表的基本套路：链表反转public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // 三指针  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\n找链表的中点public ListNode middleNode(ListNode head) &#123;  // 快慢双指针  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 至此，slow 移动至链表的中点  // 对于长度为奇数的链表，中点只有一个  // 对于长度为偶数的链表，中点有两个。此时 slow 位于第一个中点  return slow;&#125;\n\n\n找链表的倒数第 K 个节点 (使用前后双指针 former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // 让先指针 former 先走 k 步  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\n删除某节点// 找到待删除节点的前驱节点 prevprev.next = prev.next.next\n\n\n\n很多链表的中等题甚至是困难题，其实都是对于上述基本套路的缝合。\n例如，LeetCode.234 – 判断一个链表是否为回文链表 。\n\n很直观的一个做法是：使用 栈 的数据结构，先存储链表的前半部分，然后与后半部分逐个进行比对。但是这么做的话，空间复杂度就是 O(n) 了。\n存在一种空间复杂度 O(1) 的原地解法，即用到我们上面所说的基本套路操作。\n具体做法是：\n\n使用快慢指针，定位至链表的中点\n反转后半部分的链表\n比较前半部分与后半部分的链表是否完全一致public boolean isPalindrome(ListNode head) &#123;  // 定位至链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 反转后半部分的链表  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 比较两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\n常见链表面试题反转链表public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nK个一组翻转链表public ListNode reverseKGroup(ListNode head, int k) &#123;  // 判断剩余节点个数是否够 k 个  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // 翻转接下来的 k 个节点  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 尾部连接  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\n合并两个有序链表public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\n另外，也可以使用迭代法 (类似于归并排序) 。\n判断是否为环形链表public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n延伸问题： 找到环的入口节点\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\n相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // 保证两个链表的剩余长度一致  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\n链表相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // 不足补0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // 存在进位现象  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\n重排链表public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // 找到链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 由此，将整个链表分为两部分。  // 前半部分是 [head,mid] ；后半部分是 [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // 反转后半部分的链表  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 合并两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\n删除链表的重复元素public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // 去重    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\n两两交换链表中的节点public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\n链表排序public ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\n分隔链表public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["算法","链表"]},{"title":"「二分最值」 二分法还能这么用？！","url":"/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/","content":"前言本文的知识是建立于熟悉掌握二分法的思想与模板代码之上的。\n因此，如果存在任何不确定&#x2F;疑问，可以先移步至此 👉 「二分法」二分最硬干货，就在这了！ ，其中给出了实用的二分查找模板代码。\n如果已经温习完毕&#x2F;足够熟悉，那么，接下来就开始了~\n\n\n总体思路最核心的问题是，为什么这类题目可以使用二分法？又没有什么有序数组，也没有什么查找目标，这是干嘛呢？\n原因在于这类最值问题的答案本身具有二段性。\n所谓二段性，翻译成大白话就是：假设我在 h 小时内到达 d 的最小速度是 s ，那么如果我以 s-1 的速度出发，就一定不能在 h 小时内到达 d 。\n而我们使用二分查找，其实就是在查找这个临界最值，即答案。\n\n如果求的是在满足要求下的最小值，那么查询目标就是第一个满足要求的数值；\n如果求的是在满足要求下的最大值，那么查询目标就是最后一个满足要求的数值。\n\n\n\n概括而言，可以将这类问题的解题步骤分为两部分：\n\n确定答案区间。左区间一般取0或1，而右区间取题目规定的最大数据范围。\n根据题目所求，确定二分模板。\n编写检验函数 check()。这也是最困难，最不确定的一部分。每个题目需要具体情况具体分析。\n\n\n\n题单汇总 🏷️显式最值问题简单计算LeetCode.1283 – 使结果不超过阈值的最小除数题面\n给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。\n每个数除以除数后都向上取整，比方说 7&#x2F;3 &#x3D; 3 ，10&#x2F;2 &#x3D; 5 。\n题目保证一定有解。\n\n示例 1：\n\n输入：nums &#x3D; [1,2,5,9], threshold &#x3D; 6输出：5解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n\n\n\n代码class Solution &#123;  public int smallestDivisor(int[] nums, int threshold) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, threshold, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 divisor 作为除数，使得结果不超过 threshold */  private boolean check(int[] nums, int threshold, int divisor) &#123;    int sum = 0;    for (int num : nums) &#123;      sum += num / divisor + (num % divisor == 0 ? 0 : 1);    &#125;    return sum &lt;= threshold;  &#125;&#125;\n\n\n\nLeetCode.1300 – 转变数组后最接近目标值的数组和题面\n给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。\n如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。\n请注意，答案不一定是 arr 中的数字。\n\n示例 1：\n\n输入：arr &#x3D; [4,9,3], target &#x3D; 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n\n\n\n代码class Solution &#123;  public int findBestValue(int[] arr, int target) &#123;    int left = 0, right = 0;    for (int num : arr) &#123;      right = Math.max(right, num);    &#125;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(arr, target, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    int sum1 = getSum(arr, left - 1), sum2 = getSum(arr, left);    return target - sum1 &lt;= sum2 - target ? left - 1 : left;  &#125;    private boolean check(int[] arr, int target, int value) &#123;    return getSum(arr, value) &gt;= target;  &#125;  private int getSum(int[] arr, int value) &#123;    int sum = 0;    for (int num : arr) &#123;      sum += Math.min(num, value);    &#125;    return sum;  &#125;&#125;\n\n\n\nLeetCode.875 – 爱吃香蕉的珂珂题面\n珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。\n珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n\n示例 1：\n\n输入：piles &#x3D; [3,6,7,11], h &#x3D; 8\n输出：4\n\n\n\n代码class Solution &#123;  public int minEatingSpeed(int[] piles, int h) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(piles, h, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 speed 的速度，在 h 小时内吃完所有香蕉 */  private boolean check(int[] piles, int h, int speed) &#123;    int cost = 0;    for (int pile : piles) &#123;      cost += pile / speed + (pile % speed == 0 ? 0 : 1);    &#125;    return cost &lt;= h;  &#125;&#125;\n\n\n\nLeetCode.2064 – 分配给商店的最多商品的最小值题面\n给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。\n你需要将 所有商品 分配到零售商店，并遵守这些规则：\n一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。请你返回最小的可能的 x 。\n\n示例 1：\n\n输入：n &#x3D; 6, quantities &#x3D; [11,6]输出：3解释：一种最优方案为：\n\n11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) &#x3D; 3 。\n\n\n\n\n代码class Solution &#123;  public int minimizedMaximum(int n, int[] quantities) &#123;    // TODO  &#125;&#125;\n\n\n\nLeetCode.1870 – 准时到达的列车最小时速题面\n给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。\n每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。\n例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。\n生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。\n\n示例 1：\n\n输入：dist &#x3D; [1,3,2], hour &#x3D; 6输出：1解释：速度为 1 时：\n\n第 1 趟列车运行需要 1&#x2F;1 &#x3D; 1 小时。\n由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3&#x2F;1 &#x3D; 3 小时。\n由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2&#x2F;1 &#x3D; 2 小时。\n你将会恰好在第 6 小时到达。\n\n\n\n\n代码class Solution &#123;  public int minSpeedOnTime(int[] dist, double hour) &#123;    if (dist.length - 1 &gt; (int) hour || (dist.length - 1 == (int) hour &amp;&amp; hour % (int) hour == 0)) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e7;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(dist, hour, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 speed 的速度，在 hour 小时内到达终点 */  private boolean check(int[] dist, double hour, int speed) &#123;    int cost = 0;    for (int i = 0; i &lt; dist.length - 1; i++) &#123;      cost += dist[i] / speed + (dist[i] % speed == 0 ? 0 : 1);    &#125;    return cost + (double) dist[dist.length - 1] / speed &lt;= hour;  &#125;&#125;\n\n\n\nLeetCode.2187 – 完成旅途的最少时间题面\n给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。\n每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。\n给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3], totalTrips &#x3D; 5输出：3解释：\n\n时刻 t &#x3D; 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。已完成的总旅途数为 1 + 0 + 0 &#x3D; 1 。\n时刻 t &#x3D; 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。已完成的总旅途数为 2 + 1 + 0 &#x3D; 3 。\n时刻 t &#x3D; 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。已完成的总旅途数为 3 + 1 + 1 &#x3D; 5 。所以总共完成至少 5 趟旅途的最少时间为 3 。\n\n\n\n\n代码class Solution &#123;  public long minimumTime(int[] time, int totalTrips) &#123;    long left = 1L, right = (long) 1e14;    while (left &lt; right) &#123;      long middle = left + ((right - left) &gt;&gt; 1);      if (check(time, (long) totalTrips, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 totalTime 的时间内，至少完成 totalTrips 次旅途 */  private boolean check(int[] time, long totalTrips, long totalTime) &#123;    long count = 0;    for (int t : time) &#123;      count += totalTime / t;    &#125;    return count &gt;= totalTrips;  &#125;&#125;\n\n\n\nLeetCode.1760 – 袋子里最少数目的球题面\n给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n\n示例 1：\n\n输入：nums &#x3D; [9], maxOperations &#x3D; 2输出：3解释：\n\n将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。\n将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n\n\n\n\n代码class Solution &#123;  public int minimumSize(int[] nums, int maxOperations) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, maxOperations, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 maxOperations 次操作内实现 cost 的开销 */  private boolean check(int[] nums, int maxOperations, int cost) &#123;    int count = 0;    for (int num : nums) &#123;      // 这里需要注意的细节是：      // 如果正好可以分完，那么共需要 num/cost 个袋子      // 不过算上本来就有的一个袋子，所以还需要 num/cost-1 个袋子      count += num / cost + (num % cost == 0 ? -1 : 0);    &#125;    return count &lt;= maxOperations;  &#125;&#125;\n\n\n\n历史标记LeetCode.1552 – 两球之间的磁力题面\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。\n已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。\n给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。\n\n示例 1：\n\n输入：position &#x3D; [1,2,3,4,7], m &#x3D; 3输出：3解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n\n\n\n代码class Solution &#123;  public int maxDistance(int[] position, int m) &#123;    Arrays.sort(position);    int left = 1, right = position[position.length - 1] - position[0];    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(position, m, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在任意相邻小球的间隔不超过 dist 的情况下，放入 m 个球 */  private boolean check(int[] position, int m, int dist) &#123;    int count = 1, cur = position[0];    for (int p : position) &#123;      if (cur + dist &lt;= p) &#123;        count++;        cur = p;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1482 – 制作 m 束花所需的最少天数题面\n给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n示例 1：\n\n输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1输出：3解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3\n\n\n\n代码class Solution &#123;  public int minDays(int[] bloomDay, int m, int k) &#123;    if (bloomDay.length &lt; m * k) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(bloomDay, m, k, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 waitingDay 天之内，制成 m 束花 */  private boolean check(int[] bloomDay, int m, int k, int waitingDay) &#123;    int combo = 0, count = 0;    for (int day : bloomDay) &#123;      combo = day &lt;= waitingDay ? combo + 1 : 0;      if (combo == k) &#123;        count++;        combo = 0;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1011 – 在 D 天内送达包裹的能力题面\n传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。\n\n示例 1：\n\n输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], days &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n\n\n\n代码class Solution &#123;  public int shipWithinDays(int[] weights, int days) &#123;    int left = 1, right = 500 * 5 * 10000;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(weights, days, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 capacity 的运量，在 days 天内运输完所有包裹 */  private boolean check(int[] weights, int days, int capacity) &#123;    int sum = 0, cost = 0;    for (int w : weights) &#123;      // 单个包裹的重量不能够超过总运量      if (w &gt; capacity) &#123;        return false;      &#125;      sum += w;      if (sum &gt; capacity) &#123;        sum = w;        cost++;      &#125;    &#125;    cost++;    return cost &lt;= days;  &#125;&#125;\n\n\n\nLCP.12 – 小张刷题计划题面\n为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。\n在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。\n我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3,3], m &#x3D; 2\n输出：3\n解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。\n\n\n\n代码class Solution &#123;  public int minTime(int[] time, int m) &#123;    int left = 0, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(time, m, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在一天耗时最多为 maxTime 的情况下，在 m 天内完成所有计划 */  private boolean check(int[] time, int m, int maxTime) &#123;    // maxCost 记录当天花费最久的题目，将它交给场外求助    int costTime = 0, maxCost = 0, costDay = 0;    boolean help = false;    for (int t : time) &#123;      costTime += t;      maxCost = Math.max(maxCost, t);      if (costTime &gt; maxTime) &#123;        if (!help) &#123;          costTime -= maxCost;          help = true;        &#125;        if (costTime &gt; maxTime) &#123;          costTime = maxCost = t;          costDay++;          help = false;        &#125;      &#125;    &#125;    costDay++;    return costDay &lt;= m;  &#125;&#125;\n\n\n\n规律计算LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长题面\n给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。\n\n示例 1：\n\n\n输入：mat &#x3D; [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold &#x3D; 4输出：2解释：总和小于或等于 4 的正方形的最大边长为 2，如上图所示。\n\n\n\n代码class Solution &#123;  private int m, n;  public int maxSideLength(int[][] mat, int threshold) &#123;    m = mat.length;    n = mat[0].length;    // sum[i][j] -&gt; 以 (0,0) 为左上角，(i,j) 为右下角的矩形的元素和    int[][] sum = new int[m + 1][n + 1];    for (int i = 1; i &lt;= m; i++) &#123;      for (int j = 1; j &lt;= n; j++) &#123;        // 根据容斥原理，构造二维前缀和数组        sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + mat[i - 1][j - 1];      &#125;    &#125;    int left = 0, right = Math.min(m, n);    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(sum, threshold, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 是否存在以 side 为边长的正方形，其元素和不超过 threshold */  private boolean check(int[][] sum, int threshold, int side) &#123;    for (int i = side; i &lt;= m; i++) &#123;      for (int j = side; j &lt;= n; j++) &#123;        // 根据容斥原理，得到当前正方形的元素和        int cur = sum[i][j] - sum[i - side][j] - sum[i][j - side] + sum[i - side][j - side];        if (cur &lt;= threshold) &#123;          return true;        &#125;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\nLeetCode.1954 – 收集足够苹果的最小花园周长题面\n给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 abs(i) + abs(j) 个苹果。\n你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。\n给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。\n\n示例 1：\n\n\n输入：neededApples &#x3D; 1输出：8解释：边长长度为 1 的正方形不包含任何苹果。但是边长为 2 的正方形包含 12 个苹果（如上图所示）。周长为 2 * 4 &#x3D; 8 。\n\n\n\n代码class Solution &#123;  public long minimumPerimeter(long neededApples) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(neededApples, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left * 8L;  &#125;  private boolean check(long neededApples, int len) &#123;    return len * (len + 1L) * (len + 1L) * 4L - 2L * len * (len + 1L) &gt;= neededApples;  &#125;&#125;\n\n\n\nLeetCode.1802 – 有界数组中指定下标处的最大值题面\n给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：\n\nnums.length &#x3D;&#x3D; n\nnums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n\nabs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1\nnums 中所有元素之和不超过 maxSum\nnums[index] 的值被 最大化\n\n返回你所构造的数组中的 nums[index] 。\n\n示例 1：\n\n输入：n &#x3D; 4, index &#x3D; 2,  maxSum &#x3D; 6输出：2解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n\n\n\n代码class Solution &#123;  public int maxValue(int n, int index, int maxSum) &#123;    int left = 1, right = maxSum;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(n, index, (long) maxSum, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断该数组总和是否可以不超过 maxSum ，其中下标 index 处的元素值被确定为 x */  private boolean check(int n, int index, long maxSum, int x) &#123;    // 为了尽可能使得数组总和不超过 maxSum ，所以它应该是长这样的：    // [1,1,2,3,...,x-2,x-1,x,x-1,x-2,...,3,2,1,1]    return getSum(x, index + 1) + getSum(x, n - index) - x &lt;= maxSum;  &#125;  private long getSum(int x, int len) &#123;    return x &gt;= len ? (2L * x - len + 1L) * len / 2L : (1L + x) * x / 2L + (len - x);  &#125;&#125;\n\n\n\n线性匹配[LeetCode.1898 – 可移除字符的最大数目](1898. 可移除字符的最大数目 - 力扣（LeetCode）)题面\n给你两个字符串 s 和 p ，其中 p 是 s 的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 removable ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。\n请你找出一个整数 k（0 &lt;&#x3D; k &lt;&#x3D; removable.length），选出 removable 中的 前 k 个下标，然后从 s 中移除这些下标对应的 k 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 0 &lt;&#x3D; i &lt; k ，先标记出位于 s[removable[i]] 的字符，接着移除所有标记过的字符，然后检查 p 是否仍然是 s 的一个子序列。\n返回你可以找出的 最大 k ，满足在移除字符后 p 仍然是 s 的一个子序列。\n字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。\n\n示例 1：\n\n输入：s &#x3D; “abcacb”, p &#x3D; “ab”, removable &#x3D; [3,1,0]输出：2解释：在移除下标 3 和 1 对应的字符后，”abcacb” 变成 “accb” 。“ab” 是 “accb” 的一个子序列。如果移除下标 3、1 和 0 对应的字符后，”abcacb” 变成 “ccb” ，那么 “ab” 就不再是 s 的一个子序列。因此，最大的 k 是 2 。\n\n\n\n代码class Solution &#123;  public int maximumRemovals(String s, String p, int[] removable) &#123;    int left = 0, right = removable.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(new String(s).toCharArray(), p, removable, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在删除 len 个字符后，使得 p 是 s 的一个子序列 */  private boolean check(char[] s, String p, int[] removable, int len) &#123;    for (int i = 0; i &lt; len; i++) &#123;      s[removable[i]] = &#x27;#&#x27;;    &#125;    for (int i = 0, j = 0; i &lt; s.length; i++) &#123;      if (s[i] == p.charAt(j)) &#123;        j++;      &#125;      if (j == p.length()) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\n隐式二分问题LeetCode.287 – 寻找重复数题面\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n\n示例 1：\n\n输入：nums &#x3D; [1,3,4,2,2]\n输出：2\n\n\n\n代码class Solution &#123;  public int findDuplicate(int[] nums) &#123;    // 第一个满足 小于等于 i 的元素个数超过了 i 个，那么 i 就是重复的数字    int left = 1, right = nums.length;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 判断小于等于 guess 的元素个数是否超过了 guess 个 */  private boolean check(int[] nums, int guess) &#123;    int count = 0;    for (int num : nums) &#123;      if (num &lt;= guess) &#123;        count++;      &#125;    &#125;    return count &gt; guess;  &#125;&#125;\n\n\n\nLeetCode.1648 – 销售价值减少的颜色球题面\n你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。\n这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）\n给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。\n请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。\n\n示例 1：\n\n\n输入：inventory &#x3D; [2,5], orders &#x3D; 4输出：14解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。最大总和为 2 + 5 + 4 + 3 &#x3D; 14 。\n\n\n\n代码//todo\n\n\n\nLeetCode.274 – H 指数题面\n给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。\n根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。\n如果 h 有多种可能的值，h 指数 是其中最大的那个。\n\n示例 1：\n\n输入：citations &#x3D; [3,0,6,1,5]输出：3解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n\n\n\n代码class Solution &#123;  public int hIndex(int[] citations) &#123;    int left = 0, right = citations.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(citations, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断是否有至少 h 篇论文被引用了至少 h 次 */  private boolean check(int[] citations, int h) &#123;    int count = 0;    for (int c : citations) &#123;      if (c &gt;= h) &#123;        count++;      &#125;    &#125;    return count &gt;= h;  &#125;&#125;","tags":["算法","二分查找"]},{"title":"「JSON序列化」踩坑记录","url":"/2022/07/23/%E3%80%8CJSON%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%8D%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"前言最近在实习岗位做需求的时候，因为在一个实体类里加了一个方法踩了一个大坑，直接导致整个项目出现大问题。。还好是在开发环境，但是也给其他小伙伴带来了一些影响（测试人员无法正常继续下一步操作）。所以周末有空就来记录并整理一下这个问题的原因以及解决办法。\n\n\n问题描述通过定位日志，我发现问题的原因是出现了JSON解析异常：Caused by:com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException:Unrecognized field &quot;xxx&quot;。\n而出现这样的异常的原因，说明是在反序列化创建接收体的Java对象时，有字段没有定义在该实体中。\n但是我的需求里既没有新增，也没有删除过实体类的任何属性呀！那为什么我的代码运行起来就出现这个问题了呢！实在是百思不得其解。更巧的是，这个 &quot;xxx&quot; 不是别人，正是我写的一个方法名中的一部分！这个方法名叫做 getXxx()。那就更令我感到奇怪了：我写了一个方法，然后Jackson却把这个方法名中的一部分作为一个字段，想去尝试进行解析，然后解析不到就报错了怪在我头上咯？？\n百度了半天，找到的解决方案基本就是一个：在实体类上添加注解 @JsonIgnoreProperties(ignoreUnknown = true)，表示“如果在JSON反序列化时出现了未定义的字段，那么就忽略而不报错”。这样做一定是可以解决异常的。但是我更好奇的是问题本身：为什么Jackson会把 &quot;xxx&quot; 作为一个字段呢，我根本没有这样定义啊！针对这个疑惑，一时半会找不到什么原因。为了不影响其他开发小伙伴，只能先紧急下线代码，把我的代码给暂时注释掉。\n\n\n问题原因在一个实体类中，如果你有一个以 get 作为前缀的符合驼峰式命名的方法名，且这个方法具有返回值，那么Jackson就会将 get 后面部分的内容作为一个参数的key，将方法的返回值作为参数的value，放入json中。\n举个例子：\npublic class User &#123;    private String username;        public String getUsername() &#123;        return username;    &#125;        public void setUsername(String username) &#123;        this.username = username;    &#125;        // 注意：这里是一个以 get 作为前缀的，且也是符合驼峰式命名的方法名，且这个方法也是有返回值的    public String getZhangSan() &#123;        return &quot;张三&quot;;    &#125;        public static void main(String[] args) &#123;        User user = new User();        user.setUsername(&quot;twq&quot;);        String json = objectMapper.writeValuesAsString(user);        System.out.println(json);    &#125;&#125;\n\n你以为的输出是这样的：{“username”: “twq”}，\n实际上的输出是这样的：{“username”: “twq”, “zhangSan”: “张三”}\n。。。。\n\n\n明白了问题的原因以后，我真是有些又好气又好笑。。\n\n\n解决办法既然发现了问题的原因，那么解决办法就很容易想到了。\n两种思路：要么想办法告诉Jackson忽略掉这个字段，要么就是干脆不要起名以 get 开头的方法。\n对于第一种思路，对应的办法是在这个方法上加上一个注解 @JsonIgnore，表示这个方法不需要被解析，不要给我画蛇添足！\n对于第二种思路，那就更加简单直接了：换个开头名呗，比如叫做 fetchXxx() 不也挺好的么～\n","tags":["实习记录","踩坑记录"]},{"title":"「Java」ThreadLocal笔记","url":"/2022/09/04/%E3%80%8CJava%E3%80%8DThreadLocal%E7%AC%94%E8%AE%B0/","content":"什么是ThreadLocalThreadLocal，从字面意思上直译，就是线程本地的，是将需要的变量在每个线程中都创建了一个副本。每个线程都只能访问和修改本线程中的变量副本，不能相互访问。\n假设我写一个main方法，其中创建3个线程，并且大家都使用同一个ThreadLocal对象，往里写入内容，再读取内容：\npublic class ThreadLocalTest &#123;    public static void main(String[] args) &#123;        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                threadLocal.set(1);                System.out.println(threadLocal.get());            &#125;        &#125;, &quot;Thread1&quot;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                threadLocal.set(2);                System.out.println(threadLocal.get());            &#125;        &#125;, &quot;Thread2&quot;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(threadLocal.get());            &#125;        &#125;, &quot;Thread3&quot;).start();    &#125;&#125;\n\n\n\n以上代码，得到的输出结果是：\n12null\n\n\n\n由此可以看到：虽然每个线程使用的都是同一个ThreadLocal对象，但是线程之间的变量却又无法互相访问，从而达到了线程隔离的效果。\n\n\nThreadLocal的作用\n提升性能：ThreadLocal可以让线程独占资源，存储于线程内部，避免线程堵塞造成CPU吞吐下降\n减少对内存的开销：使用同一个ThreadLocal对象，但每个线程的变量是独立的，对其他线程不可见，所以不需要每个线程都 new 一个对象。\n\n\n\nThreadLocal的工作原理学习ThreadLocal，最主要的问题就是：它是如何维护变量的副本，并做到线程隔离的？\n实际上，每个线程都有一个ThreadLocalMap。而这个ThreadLocalMap，又正是ThreadLocal的一个内部类。这个映射表的key是ThreadLocal实例本身，value 是真正需要存储的变量 Object。\n也就是说，ThreadLocal本身并不存储变量值，也没什么特别的黑科技操作。它只是作为ThreadLocalMap的key，由此可以让线程从ThreadLocalMap获取到对应的 value。\n\n\n不过，这里我在学习的时候有个困惑：同样是为了区分各个线程，达到线程隔离的效果，那这个key为啥不直接用Thread呢，干嘛还非要定义出一个叫做ThreadLocal的概念，并且以它作为key呢？\n后来我查阅网络资源+思考，想到了3个不能这么做的原因：\n\n一个线程是可以设置多个私有变量的。如果我们直接以Thread作为key，那么如何唯一标识这些value？\n如果我们直接以Thread作为key，那么这个ThreadLocalMap就必须成为一个全局共享的Map，供所有线程使用。这样一来，如果并发量比较大的话，很多个线程都在同时操作这个Map，其体积可能会膨胀，导致访问性能的下降\n既然这个ThreadLocalMap成为了一个全局共享的Map，供所有线程使用，这就意味着不知道什么时候才可以回收销毁，其生命周期过长\n\n\n\nThreadLocal的内存泄漏问题据说这是一道谈到ThreadLocal就会必问的八股式问题&#x3D; &#x3D;\n首先，先要明白什么是内存泄漏？你申请了一块内存，在使用完毕后没有释放掉资源。我自己已经没法用它了，但是系统也没法回收它。\n\n\n那为什么说ThreadLocal会存在内存泄漏问题呢？\n前面说了：ThreadLocalMap的key是每个ThreadLocal对象。如果有一个ThreadLocal对象没有外部的强引用来引用它，那么在下一次进行GC的时候，这个ThreadLocal对象就势必会被回收掉，这个value就无法再被访问到了。如果这个ThreadLocal所在的线程还在继续工作，那么这个value就会一直存在着一条强引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value，于是这个value就一直不会被回收了，就产生了内存泄漏。\n不过，这种情况发生的几率是很小的。因为，如果要使ThreadLocal产生内存泄漏，必须以下3个条件同时满足：\n\nThreadLocal被外部回收\n线程被复用\n没有再调用 set&#x2F;get&#x2F;remove 方法\n\n但是，几率再小，那也是存在。那么，如何防止内存泄漏呢？\nThreadLocal自身提供的方法 remove() 可以尝试删除key为null的entry，释放这些不会再被访问到的value对象所占用的内存。\n回到开头时的那个demo代码，我们可以进行这样的改进：\npublic class ThreadLocalTest &#123;    public static void main(String[] args) &#123;        ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    threadLocal.set(1);                    System.out.println(threadLocal.get());                &#125; finally &#123;                    // 在 finally 块进行 remove 操作，以防止内存泄漏的发生                    threadLocal.remove();                &#125;            &#125;        &#125;, &quot;Thread1&quot;).start();&#125;","tags":["Java","多线程"]},{"title":"「Java」基础不牢，地动山摇——2","url":"/2022/09/03/%E3%80%8CJava%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%E2%80%94%E2%80%942/","content":"final关键字可以作用在哪些地方，分别有什么含义？final关键字主要作用在三个地方：类、方法、变量。\n\n对于一个final修饰的类：表明这个类不可以被继承。且类中的所有方法，都会被隐式地自动作为final方法。\n\n对于一个final修饰的方法：表明这个方法不可以被子类重写。\n\n对于一个final修饰的变量：表明这个变量不可以被改变。如果这是一个基本类型的变量，那么其数值不可改变；如果这是一个引用类型的变量，那么其引用地址不可改变。\n\n不过，这里的不可变指的是引用不可变，而不是引用指向的内容的不可变。\n例如 final int[] nums = new int[3]; 但是数组内部的元素是可以随意修改的啊，nums[0] = 666;\n\n\n\n\n\n在Java中，++操作是线程安全的嘛？不是。因为它不是原子的，即：涉及到多个操作，包括读取变量的原值，然后增加1，再存储回内存。\n在这3个步骤的间隙中，可能穿插着其他线程对这个变量的操作。\n\n\na &#x3D; a + b 与 a +&#x3D; b 的区别+= 这样的写法，可以隐式地将操作的结果类型转化为结果的实际类型。\n例如：\nbyte a = 1, b = 2;a = a + b; // 编译错误，因为 a+b 的结果是一个int类型，但是接收对象却是一个byte类型a += b; // 没问题，a会被隐式地转化为int类型\n\n\n\n2 * 0.1 &#x3D;&#x3D; 0.2 的返回结果是什么？false，因为浮点数不能使用 == 来比较是否相等，否则得到的结果将永远是不相等，即使两者在数学上看起来是相等的。这样的原因是：浮点数不能精确地表示出来，在计算机的世界看来，就是不一样的。\n如果想要比较两个double类型的变量是否相等，有以下几种方法：\n\n使用 Double.compareTo() 进行精确比较：\nDouble num1 = 0.1, num2 = 0.2;if (num1.compareTo(num2) &gt; 0) &#123;    System.out.println(&quot;num1 &gt; num2&quot;);&#125; else if (num1.compareTo(num2) == 0) &#123;    System.out.println(&quot;num1 == num2&quot;);&#125; else &#123;    System.out.println(&quot;num1 &lt; num2&quot;);&#125;\n\n\n\n有时候，在需求上允许误差的存在，即：在某个允许的误差范围内，认为两个数是相等的。那么可以这样做：\nif (num1 - num2 &gt; 0.000001) &#123;    System.out.println(&quot;num1 &gt; num2&quot;);&#125; else if (num1 - num2 == 0.000001) &#123;    System.out.println(&quot;num1 == num2&quot;);&#125; else &#123;    System.out.println(&quot;num1 &lt; num2&quot;);&#125;\n\n\n\nComparator 与 Comparable 的区别是什么？Comparable接口用于定义对象的自然顺序，而Comparator接口用于定义当前排序的策略。\n从另一个角度说：对于一个对象而言，Comparable只会有一个，而Comparator可以有多个定义。\n\n\nArrayList的扩容机制\n当我们第一次 new ArrayList&lt;&gt;() 的时候，默认会有一个空的Object数组，大小为0\n当我们第一次进行 add() 的时候，这个数组会被初始化为一个大小（默认是10）\n每当进行 add() 的时候，会先判断这个数组的空间是否还够。如果不够，就要进行扩容了。\n在 ArrayList 的源码里，有一个叫做 grow() 的方法用于进行扩容，默认是扩容至原来的1.5倍。空间扩容完毕后，会调用 Arrays.copyOf() 方法来拷贝数组元素。\n\n\n\n如何在遍历ArrayList的过程中删除指定元素？/** * 方法一：for循环正向遍历。但是要注意，每当删除了一个元素，需要i--来抵消「后继元素都向前移动补位」的影响 */public void doRemove1(List&lt;String&gt; list, String target) &#123;    for (int i = 0; i &lt; list.size(); i++) &#123;        if (target.equals(list.get(i))) &#123;            list.remove(i--);        &#125;    &#125;&#125;/** * 方法二：for循环逆向遍历。如此一来，就不用顾虑「后继元素移动补位」带来的影响了 */public void doRemove2(List&lt;String&gt; list, String target) &#123;    for (int i = list.size() - 1; i &gt;= 0; i--) &#123;        if (target.equals(list.get(i))) &#123;            list.remove(i);        &#125;    &#125;&#125;/** * 方法三：使用 Iterator 迭代器进行遍历与移除的操作。这是一种最为稳妥的方式 */public void doRemove3(List&lt;String&gt; list, String target) &#123;    Iterator&lt;String&gt; iterator = list.iterator();    while (iterator.hasNext()) &#123;        if (target.equals(iterator.next())) &#123;            iterator.remove();        &#125;    &#125;&#125;\n\n\n\n另外，请千万记住不要在这个过程中使用 for-each 的方式来遍历！！否则，会产生 ConcurrentModificationException 异常，原因是 modCount != expectedModCount。\n这里的 modCount 和 expectedModCount，就涉及到 ArrayList 的源码内容了，总之它们是 ArrayList 的两个属性。而抛出异常的原因就是，实际!&#x3D;预期。\n具体地讲，modCount 是指这个list对象从创建到现在被修改的实际次数，每当调用add()或者remove()方法时，modCount都会对应地增减；expectedModCount 是指这个list对象从创建到现在被修改的期望次数。\n在创建之时，modCount被赋值给了expectedModCount，但是在调用list的add()和remove()方法的时候，不会同时对应地增减expectedModCount，这样就导致两个count不相等，从而抛出异常。\n\n\nHashSet的去重原理？通过阅读HashSet的源码可知：HashSet就是基于HashMap来实现的。\n以add()方法举例，其实就相当于在一个HashMap里进行put()操作：\nprivate transient HashMap&lt;E, Object&gt; map = new HashMap&lt;&gt;();private static final Object PRESENT = new Object();public boolean add(E e) &#123;    return map.put(e, PRESENT) == null;&#125;\n\n\n\n也就是说，在进行HashSet的add()方法的时候，这个元素其实就被作为key，放入了HashSet内部维护的HashMap里。而每个Entry的value，其实对于HashSet而言并不关心，所以随便拿个东西来填充就好（在源码中，是用一个Object常量对象）。\n而我们知道，HashMap是不允许存储重复的key的。如此一来，HashSet就拥有了去重性。\n另外补充一句HashSet的add()的逻辑：\n\n每当put()的key已经存在于Map中的时候，会直接将新的value覆盖旧的value，并总是返回之前的value的值。\n所以，如果返回值是null，意味着之前还不存在这样的key，也就是是唯一的，此时就返回true。否则返回false。\n\n\n\nHashMap如何检查key是否重复？每当你进行put()操作时，HashMap会先计算这个key对象的hashCode值，来对这个待加入的key做一个预判断，同时也是为了确定该将这个Entry插入在什么位置。\n如果没有相同的hashCode，那么HashMap就会认为这个key是不重复的，可以插入；\n如果有了相同的hashCode，那么HashMap会进行下一步的最终判断，即：调用equals()方法，来检查这两个key的对象是否真的相同？如果equals()的结果也是true，那么HashMap就认为出现了重复的key，就不会让put()成功。\n\n\nHashMap如何解决哈希冲突？这个问题，需要按照JDK的版本来进行分类讨论。\n\n在JDK1.8以前，HashMap的底层是 数组+链表 的结构。通过key的hashCode，来确定需要将新的Entry存放在数组的哪个索引位置处。如果该位置已经存在了别的元素，再通过equals()判断这两个key是否真的相同。如果相同，直接覆盖value；否则就是哈希冲突，通过拉链法来解决。\n所谓拉链法，就是在这个数组位置处创建一个链表。每遇到哈希冲突时，将冲突的值加到这个链表中即可。\n但是，在极端情况下（如果你有一个非常糟糕的hashCode算法，几乎每个key的hashCode都相等），可以想象：所有的Entry都在同一个数组位置，且有一个很长很长的拉链。此时，HashMap退化成了一个链表！！查询操作的时间复杂度一下子上来了。。这也是接下来的JDK1.8的优化方向。\n\n在JDK1.8及以后，HashMap的底层是 数组+链表+红黑树 的结构。当链表长度大于阈值（默认是8，static final int TREEIFY_THRESHOLD = 8;）时，链表会转化为红黑树，使搜索的整体性能趋于一个稳定值。\n\n\n","tags":["Java","八股文"]},{"title":"「MySQL」SELECT语句执行流程","url":"/2022/04/11/%E3%80%8CMySQL%E3%80%8DSELECT%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","content":"SELECT 语句处理顺序：\nfrom\non\njoin\nwhere\ngroup by（自此开始，可以使用 select 中起的别名）\n聚合函数（avg, sum, count, ….）\nhaving\nselect\ndistinct\norder by\nlimit\n\n\n\n过程解释：\n对 from 子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（若有3个表以上，选择其中相对小的两表），求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（CROSS JOIN）。\n\n应用 on 筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足 on 逻辑表达式的行，生成虚拟表 vt2 。\n\n如果是 outer join 就添加外部行；如果是 left outer join 就把左表在第二步中过滤后的行添加进来；如果是 right outer join 那么就将右表在第二步中过滤后的行添加进来。\n最终生成虚拟表 vt3 。\n如果 from 子句中的表的数目多于两个，那么就将 vt3 和第三个表连接从而计算笛卡尔乘积，生成虚拟表。\n该过程就是一个重复 1-3 的步骤，最终得到一个新的虚拟表 vt3 。\n\n应用 where 筛选器，对上一步生成的虚拟表 vt3 引用 where 筛选器，生成虚拟表 vt4 。\n在对于包含 outer join 子句的查询，到底在 on 筛选器还是用 where 筛选器指定逻辑表达式呢？事实上，on 只会筛选 outer join 阶段的虚拟表，不会对 from 的表进行筛选 ，所以 where 才是最终筛选。\n\ngroup by 子句，将列中唯一的值组合成为一组，得到虚拟表 vt5 。\n如果应用了 group by ，那么后面的所有步骤都只能得到的 vt5 的列或者是聚合函数（count、sum、avg 等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。\n\n应用 having 筛选器，⽣成 vt7 。having 筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。\nhaving 后可以直接跟用聚合函数。having 语句的存在就是为了解决 where 中无法使用聚合函数的问题。\n\n处理 select 子句。将 vt7 中的在 select 中出现的列筛选出来，得到 vt8\n\n应用 distinct 子句，将 vt8 中重复的行移除掉，得到 vt9 。\n如果已经应用了 group by 子句，那么 distinct 其实就是多余的。原因在于：分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所有的记录本身就是不重复的。\n\n应用 order by 子句。按照 order_by_condition 排序 vt9 。\n排序是很需要成本的，除非你必须要排序，否则最好不要指定 order by\n\n取出指定行的记录，产生虚拟表 vt11 , 并将结果返回。这就是最终结果表。\n\n\n","tags":["MySQL"]},{"title":"「Java」基础不牢，地动山摇——1","url":"/2022/04/18/%E3%80%8CJava%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%E2%80%94%E2%80%941/","content":"四种访问修饰符的作用范围？\n\n\n修饰符\n当前类\n同包下\n子类\n其他包下\n\n\n\npublic\n✔️\n✔️\n✔️\n✔️\n\n\nprotected\n✔️\n✔️\n✔️\n❌\n\n\ndefault\n✔️\n✔️\n❌\n❌\n\n\nprivate\n✔️\n❌\n❌\n❌\n\n\n\n\n基本类型转换\n向上转型没有任何问题。如 long b = 1;\n向下转向会造成精度损失，因此如果需要，必须显式地进行强制转换。如 float f = (float) 2.3;\n\n打个比喻：小杯的水倒进一个大杯里肯定没问题。但大杯的水倒进小杯就不行了，可能会溢出。\n\n\n常量池Java的基本类型的包装类大部分都实现了常量池技术，除了 Float 和 Double。\n\n\n\nByte\nShort\nInteger\nLong\nCharacter\nBoolean\n\n\n\n[-128,127]\n[-128,127]\n[-128,127]\n[-128,127]\n[0,127]\nTrue&#x2F;False\n\n\n简单地说，如果使用的对象的字面量的值在常量池的范围之内，那么就不会创建新的包装类型对象，而是直接引用常量池中的对象。\nInteger a = 100, b = 100, c = 1000, d = 1000;System.out.println(a == b);  // trueSystem.out.println(c == d);  // false\n\n\n\n字符串常量池我们常用的字符串类型 String 也有对应的常量池，称为字符串常量池。不过这和上面提到的包装类型的常量池有些不同的是，字符串常量池事先不会缓存任何内容，而是在每次创建字符串时进行判断：如果已经在常量池中存在，那么就直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。维护字符串常量池的全局表叫做 StringTable，在JVM中仅有一份实例，并被所有类共享使用。\n在Java中，有两种创建字符串对象的方式：\n\nString str = &quot;hello&quot;;\n这种方式下，由于是通过字面量直接创建，所以在编译的时候对于JVM而言是可以确定的。如果 “hello” 已存在于常量池中，那么直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。\n\nString str = new String(&quot;hello&quot;);\n这种方式下，是通过构造器创建对象，在运行时在堆中创建的。所以它不仅会在常量池中创建一个 “hello” 实例，还会在堆中创建一个 String 对象。\n\n\n可以认为，后者包含了前者。\n\n\n重载和重写的区别？\n重载 Overload 是发生在同一个类中的：\n同名的方法，但是有着不同的参数列表 (参数类型不同&#x2F;参数个数不同)。\n\n重写 Override 是发生在父类与子类之间的：\n子类对父类中提供的某方法进行逻辑的重新定义。\n规定子类被重写方法和父类被重写方法的返回值必须相同，且不能比父类被重写方法声明更多的异常。\n\n\n\n\n为什么说重写 equals() 就要重写 hashCode() ？这其实是一种规定。\n换句话说，如果我们不遵守这样的规定，那么最直接的影响是使用哈希结构的容器就可能出现重大问题，因为它们的底层依赖的正是对象的 hashCode() 方法，而你却没有重写它。例如，HashSet 本身是具有去重功能的，但是现在就出问题了：逻辑上明明相同的两个对象，理应只会有一个存在于容器中。但是由于你没有重写 hashCode() 方法，导致两个相等的对象都在Set集合之中。\n另外提一句：equals() 相等的两个对象，hashCode() 要保证一定相等；但是 hashCode() 相等的两个对象，equals() 并不一定要相等。\n理由也很简单：因为 hashCode() 相等也有可能是哈希冲突导致的，实质上是两个不相干的对象。\n\n\nJVM 加载 class 文件的过程？JVM中的类加载过程，都是由类加载器来实现的。当Java程序需要使用某个类时，JVM需要确保这个类已经被加载进内存中，并被成功初始化。\n\n加载：\n在经过编译后，会生成 .class 的字节码文件。通常是使用字节数组来读入字节码文件，并在内存中产生与之对应的 Class 对象。\n\n检验：\n经过了加载的步骤，其实 Class 对象还是不完整的。还需要进行一些检验操作：\n\n该类是否存在父类？如果存在，那么必须要确保父类也已经初始化完毕。\n该类是否存在初始化语句块？如果存在，那么需要依次执行这些代码。\n\n\n\n总体顺序是这样的：\n\n父类到子类依次执行静态初始代码块\n父类执行非静态初始代码块和构造器方法，然后子类执行非静态初始代码块和构造器方法\n\nJVM的类加载器包括：\n\nBootstrapClassLoader 根加载器：负责加载JVM的基础核心类库\nExtensionClassLoader 扩展加载器：负责加载JVM的扩展类库\nApplicationClassLoader 应用类加载器：负责加载 classpath 下的类文件，即我们日常编写出来的代码\n\n为了确保同一份字节码文件不会被多个类加载器重复加载，所以 JVM 还推出了一个叫做「双亲委派」的机制：当来了一个需要被加载的字节码文件时，当前类加载器不会直接加载它，而是向上抛给它的父加载器。只有当父加载器无法处理时，才返回由当前类加载器进行处理。这样就保证了一份字节码文件仅会被一个类加载器所处理。\n\n\n创建对象的几种方式？\nnew 创建新对象\n使用反射机制\n使用 clone 机制\n通过反序列化方式\n\n\n\n方法参数传递到底是引用传递还是值传递？值传递。\n如果参数是一个基本类型的数据，那么传递的是数据的字面值本身。\n如果参数是一个引用类型的对象，那么传递的是对象的引用地址值。在被调用的过程中，对象的属性可以被修改，并影响到调用者；对象的引用也可以被修改，但是不会影响到调用者。\n\n\n字符串拼接问题String 作为不可变类，它是只读的，对象的内容是无法被改变的。如果需要修改内容，那么只能再通过创建一个新的字符串对象。如果在修改操作十分频繁的场景下，性能就显得十分低下了。\n因此，JDK5开始，引入了 StringBuilder&#x2F;StringBuffer 类，专门用于字符串拼接、删除、插入等修改操作。两者的区别在于线程安全性，由于后者的所有方法都被 synchronized 修饰，因此是线程安全的，但是效率就不如前者了。\n\n\n在JDK8以前，如果在两个字符串对象之间使用 “+” 进行拼接，会生成中间对象。不过，在Java8开始，JVM在编译期对 “+” 进行了优化，变成了基于 StringBuilder 的 append() 方法。所以，经过编译器的处理，加号拼接的性能和 StringBuilder 是一样的！\n当然，如果是循环里进行拼接操作，那么还是建议用 StringBuilder 来显式地调用，否则每循环一次就会创建一个新的 StringBuilder 对象，这肯定不如把 StringBuilder 显式地放在循环外部来得好。\n\n\n抽象类和接口的区别？\n相同点：\n\n它们天生的作用就是被继承&#x2F;实现。不可以被实例化，即不能通过 new 来创建对象。\n可以使用抽象类&#x2F;接口类的引用。如 UserService service = new UserServiceImpl();\n一个类如果继承&#x2F;实现了抽象类&#x2F;接口，那么它就需要对其中的所有抽象方法进行 @Override 重写实现。\n\n\n不同点：\n抽象类和普通类的区别就在于：它可以声明抽象方法 (注意我这里的用词是可以，不是必须)。换句话说，抽象类不一定都要有抽象方法，但具有抽象方法的都一定是抽象类。\n\n接口比抽象类更加“抽象”：抽象类可以存在非抽象方法，但是接口中的方法都必须是抽象的。\n抽象类作为一种类，可以定义构造器、成员变量，并且可以用 public, protected, default, private 来修饰；接口不能定义构造器，成员变量只能用 public 来修饰 (而且，这种变量实质上都是常量)。\n\n\n\n另外一个容易困扰的问题是：如何确定我应该使用接口还是抽象类？\n\n如果你想标记一个类的某些特征，使用接口（例如 Serializable 接口用于标记可以进行序列化的类）。\n如果你需要调用的方法与类没有关系，使用接口。\n如果你需要向其他类提供一系列的模板方法并且希望它们都能提供一个自己的版本，使用抽象类。\n\n\n\ntry…catch…finally 坑爹题\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      System.out.print(&quot;3&quot;);    &#125;  &#125;&#125;\n\n答案：31\n在 try 返回前，会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的结果 1。\n\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      return 3;    &#125;  &#125;&#125;\n\n答案：3\n在 try 返回前，会先执行 finally 语句块。然而这里的 finally 却不按套路出牌，直接 return 了。\n\n\n\n\nI&#x2F;O流有哪些？\n按照流向：输入流、输出流\n按照操作单元：字节流、字符流\n\nInputStream&#x2F;Reader：所有输入流的基类。前者是字节输入流，后者是字符输入流。\nOutputStream&#x2F;Writer：所有输出流的基类。前者是字节输出流，后者是字符输出流。\n\n\n序列化什么是序列化&#x2F;反序列化？序列化：把Java对象转为二进制流，以方便在网络中进行传输。\n反序列化：把二进制流恢复为Java对象。\n好比生活中对一些大件物品的运输，在运输时将它拆分再打包，使用时再重新组装。\n\n\n如何实现序列化？需要让该Java对象所属的类实现 Serializable 接口。\nSerializable 接口没有什么具体的作用，它只是一个标识性接口。但是如果不实现这个接口，在一些序列化场景下会出错。\n所以一般建议，创建的JavaBean类都实现 Serializable 接口。\n\n\n可以不参与序列化吗？可以。对于那些不想进行序列化的变量，可以使用关键字 transient 进行修饰。\n\n\n常见的序列化手段？\nJava对象流：一般是对象输出流 ObjectOutputStream 和对象输入流 ObjectInputStream\nJSON：很多第三方JSON技术，如Jackson、FastJson、GSON\nProtoBuff：一种轻便高效的结构化数据存储格式，可以大大减少数据传输大小，提高系统性能。\n\n\n\n泛型泛型擦除是什么？Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。也就是说，在运行的时候是没有泛型的。\n这样做的目的，主要是为了能够使JVM向下兼容，因为在JDK5之前是没有泛型的。\n\n\n反射什么是反射？普通的创建对象，是通过 new 的方式。这种方式相当于在编译时已经确定了类型信息。\n如果想在运行时动态地获取类信息，进而创建对应的类型实例，那么就需要使用反射了。\n通过反射，可以获取任意一个类的任意属性和方法，并调用它们。\n通过设置 setAccessible(true)，就连 private 的属性也可以获取到。\n\n总结而言，反射的作用主要有：\n\n在运行时创建任意一个类的对象\n在运行时获取任意一个对象的类信息\n在运行时获取任意一个对象的属性和方法，并进行调用\n生成动态代理对象\n\n\n\n反射的原理是什么？在类加载时期，JVM使用类加载器将字节码文件加载入内存。反射就是在这个期间获取类信息，然后进行各种操作。\n\n\n反射有哪些使用场景？一般而言，我们很少会直接接触并编写反射代码。但是，这并不代表反射没有用。相反，正是因为反射，才能这么轻松地使用各种框架。\n\nSpring框架中，利用反射机制来注入属性、调用方法。\nJDBC中，利用反射机制来动态加载数据库的驱动类。\n\n\n\n反射的使用姿势\n通过全限定类名创建一个对象\nClass clazz1 = Class.forName(&quot;java.lang.String&quot;);Class clazz2 = &quot;hello&quot;.getClass();\n\n\n\n创建一个实例对象\n// 第一种方式：通过class对象的 newInstance() 方法Object obj1 = clazz.newInstance();// 第二种方式：通过class对象获得对应的构造器对象，再使用构造器对象的 newInstance() 方法Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(new Class[]&#123;String.class&#125;);Object obj2 = constructor.newInstance(new Object[]&#123;&quot;hello&quot;&#125;);\n\n\n\n通过class对象获得一个属性对象 Field\n// getFields 可以获取public属性Field field1 = clazz.getFields();// getDeclaredFields 可以获取所有属性Field field2 = clazz.getDeclaredFields();\n\n\n\n通过class对象获得一个方法对象 Method\n// getMethod 可以获取public方法Method method1 = clazz.getMethod(String methodName);// getDeclaredMethod 可以获取所有方法Method method2 = clazz.getDeclaredMethod(String methodName);// 可以执行private方法method2.setAccessible(true);\n\n执行方法\nmethod.invoke(obj);\n\n\n例子：\nimport java.lang.reflect.Method;public class Main &#123;  public static void main(String[] args) throws Exception &#123;    String s1 = &quot;hello&quot;;    // 通过对象.getClass()得到一个class对象，并获得指定的方法对象    Method method = s1.getClass().getMethod(&quot;toUpperCase&quot;);    // 调用该方法    String s2 = method.invoke(s1); // HELLO  &#125;&#125;\n\n\n\n设计模式手写个单例模式类？注意点：\n\n保证构造器方法是不对外暴露的，即：将默认无参构造方法声明为 private\n通过唯一的公开静态方法向外界提供单例实例\n\n\n饿汉式 (线程安全)\npublic class Singleton &#123;   private static Singleton singleton = new Singleton();    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    return singleton;  &#125;&#125;\n\n\n\n懒汉式1 (线程不安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n\n\n懒汉式2 (synchronized 线程安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static synchronized Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n\n\n懒汉式3 (volatile+DCL 线程安全)\npublic class Singleton &#123;   private static volatile Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n\n\n懒汉式4 (静态内部类 线程安全)\npublic class Singleton &#123;    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;    private static final Singleton SINGLETON = new Singleton();  &#125;    public static Singleton getSingleton() &#123;    return SingletonHolder.SINGLETON;  &#125;&#125;\n\n在实际工程中，使用哪种方式来实现保证单例都是可以的。即使是最为简单粗暴的饿汉式的单例模式，问题也不大，因为现在的内存也不再那么稀缺了，而且这种实现的代码可读性挺好的。\n\n\n设计模式及其实际应用\nSpring的IOC容器应用了工厂模式，通过 ApplicationContext 或 BeanFactory 来创建并管理对象，然后使用反射机制来获取对象。\n\n\n\nBeanFactory\nApplicationContext\n\n\n\n懒加载\n即时加载\n\n\n不支持注解形式的依赖\n支持注解形式的依赖\n\n\n一般使用的IOC容器实现类都是 ApplicationContext 接口，它扩展了 BeanFactory 接口。\n\nSpring的对象默认是单例模式的。Spring源码中对于单例模式的实现，使用的是 volatile+DCL 方式。\n\nSpringAOP 使用了代理模式。\n具体实现可能是JDK动态代理，也可能是CGLib动态代理。这取决于目标代理对象是否是一个接口的实现类，如果是则会使用JDK动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n","tags":["Java","八股文"]},{"title":"「Redis」关于缓存与数据库的一致性问题","url":"/2022/09/13/%E3%80%8CRedis%E3%80%8D%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","content":"前言在当今的项目中，高并发场景是越来越多了，缓存逐渐成为了一个不可或缺的中间件。\n当我们使用缓存给我们带来的读取性能的提升时，我们必须要思考一个问题：如何保证缓存与数据库的数据一致性？\n\n\n更新策略如果你的项目场景严格要求缓存与数据库的实时一致性，那么方案只有一个：读请求与写请求的串行化，串联在一个内存队列里。因为串行化可以保证两者的数据一致性，但这样做会导致系统的吞吐量大幅下降，需要配置比正常情况下多几倍的机器数量来支撑线上的请求。\n否则，如果允许缓存和数据库偶尔有不一致的情况（这是普遍场景），就不要考虑串行化的方案了！不管怎么说，反正有一点是很明确的：每当数据发送改变时，不仅数据库需要改，缓存的数据也要改。只是，改也总有个先后顺序，应该怎么安排更加合适？\n\n\nCache Aside Pattern这是最经典的一种应用方案：\n\n读请求时，先读缓存，缓存没有再读数据库，并将数据存入缓存，最后返回响应\n写请求时，先更新数据库，成功后删除缓存的对应数据\n\n这时候我有个疑惑：为什么是删除缓存数据，而不是直接更新缓存？查阅了一下资料寻找原因，其实是出于计算开销的角度考虑的。\n每次修改数据库的时候，都要将其对应的缓存也进行更新。但也许有些场景存在比较复杂的缓存数据计算，如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？所以说「删除缓存，而不是更新缓存」，就是一个lazy的思想，不要每次都马上重新做复杂的计算，等到它需要被使用的时候再进行计算。\n\n\n防止失败的解决方案既然我们已经确定了「先更新数据库，成功后删除缓存的对应数据」这样的更新策略，那么如果这个过程出现了问题该怎么办？比如，更新数据库确实是成功了，但是删除缓存失败了。\n有两个解决思路：\n\n延时双删。把「删除缓存」这个操作在一段延时后再执行一次。\npublic void update(String key, String value) &#123;    updateDatabase(key, value);    deleteCache(key);    // ....    // delete again    deleteCache(key);&#125;\n\n\n\n把策略改为「先删除缓存，成功后更新数据库」。\n如果数据库更新失败了，那么数据库中仍然是旧值，而缓存由于删除成功所以是空的。等到读请求的时候，因为缓存没有，所以去读了数据库中的旧值，然后更新到缓存中。如此一来，数据起码是一致的。\n\n\n\n\n后记前面提到的方法二，即“把策略改为「先删除缓存，成功后更新数据库」”，在上亿流量的高并发场景下，可能还是会存在不一致问题。\n试想：数据发生了变更，按照策略我先删除了缓存，然后再去更新数据库。此时还没修改完成，又有一个读请求过来了，它先去找缓存，发现缓存没有，就去查询数据库了，直接查到了修改前的旧值，并存入了缓存中。随后，数据库的更新操作才刚完成。于是，数据库和缓存中的数据不一样了…\n\n\n如果要继续深入讨论这一问题，结合网上的文档文章，我所了解到的方案是：\n\n在更新数据的时候，可以将数据的唯一标识发送到一个 jvm 的内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据这个唯一标识路由之后，也发送到同一个 jvm 内部队列中。\n一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果有一个读请求，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。\n等到那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后才存入缓存中。\n如果读请求还在等待时间范围内，可以不断地轮询缓存，只要发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取旧值。\n\n","tags":["中间件","Redis"]},{"title":"「Redis」Redis入门记录","url":"/2022/09/13/%E3%80%8CRedis%E3%80%8DRedis%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/","content":"前言Redis是一种特殊的数据库，它的特殊之处在于，数据是存储在内存中而非磁盘上的。所以，它的读写速度相较于传统的数据库（如MySQL）会快很多，因此被广泛应用于作为缓存。\n此外，Redis在项目应用中，还可以用来作为分布式锁。\n\n\n为什么要用Redis？回答这个问题，主要就是回答：我们为什么需要缓存？\n\n高性能：\n假设某个用户第一次访问数据库中的某些数据。读取的过程会比较慢，因为它是从磁盘上读取的。\n我们可以对这个过程进行一次优化：当用户第一次读取了某个数据后，将这个数据缓存在内存中。这样，当他下次再访问这个内容的时候，就可以直接从内存中快速读取了，不必再去从磁盘上找了。\n但是，每当数据库中的内容发生了改变之后，需要同步更新内存中的数据！这里就牵涉到了另一个问题：**如何保证缓存与数据库的数据一致性？**\n\n高并发：\n当你的项目服务是一个高并发的场景时，分担请求压力就显得十分重要了。如果瞬时的大流量全部都来访问数据库，那么可能会直接让整个数据库服务宕机。\n因此，如果我们能有缓存的话，就可以分担相当一部分的请求。\n这里引出了另外三个问题：缓存雪崩、穿透、击穿问题。\n\n\n\n\nRedis的过期策略在写线上项目的代码的时候，遇到过比较“神奇”的现象：明明之前写进Redis里的数据，怎么现在丢了不见了？\n当时觉得奇怪，现在想想反而觉得奇怪才是奇怪！Redis是缓存，不是用来当存储的！Redis主要是基于内存来进行高性能、高并发的读写操作的。\n既然内存是有限的，比如 Redis 就只能用 10G，你要是往里面写了 20G 的数据，会咋办？当然会干掉 10G 的数据，然后就保留 10G 的数据了。那干掉哪些数据，保留哪些数据？这就涉及到Redis的过期策略了。\nRedis的过期策略是：定期检查删除+惰性删除。\n\n所谓「定期检查删除」，是指：Redis会在每隔一段时间（默认是100ms）随机抽取一些设置了过期时间的key，检查它们是否已经过期，如果过期就删除。\n至于为什么是随机抽取而不是全部扫描，是为了平衡开销而考虑的。假设Redis里面有10w个设置了过期时间的key，然后每隔100ms就要全部扫描10w个key，那Redis基本上就没法玩了，CPU资源全用来检查是否过期了。\n\n所谓「惰性删除」，是指：在实际使用到某个key的时候，Redis会先检查一下这个key是否已经过期，如果过期就删除，然后返回null作为获取结果。\n\n\n虽然有了这样的过期机制，但其实还是有问题的：「定期检查删除」是有可能漏掉很多已经明明过期了的key，如果这些key很长一段时间内没有被查询（没有进行惰性删除），那么就会有大量的过期key堆积在Redis里，占据着大量内存。久而久之如果Redis的内存满了，这时候再要写入一个新的key该怎么办？这就涉及到了内存淘汰机制。\nRedis有6种内存淘汰机制：\n\nnoeviction： 当内存不足以容纳新写入数据时，新写入操作会报错。（这个一般没人用吧，实在是太恶心了）\nallkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。（这个是最常用的）\nallkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。（这个很少用，除非有什么特殊场景需要随机？）\nvolatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。（这个一般不太合适）\nvolatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。（也很少用，干啥要随机呢？）\nvolatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除过期时间最早的 key。\n\nLRU算法前面说了，最常用的内存淘汰机制是allkeys-lru，即LRU(Least Recently Used)算法，也就是说 LRU 算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好 LRU 算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。\n\n现在面试是越来越卷了，据说某些公司考察候选者的算法题，其中就会让他手写一个LRU算法 :(\n先不说纯手写从底层写一个LRU结构，我们看看如何利用JDK官方自带的数据结构来实现一个LRU？\n\npublic class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private int capacity;    /**     * 传递进来最多能缓存多少数据     *     * @param capacity 缓存大小     */    public LRUCache(int capacity) &#123;        super(capacity, 0.75f, true);        this.capacity = capacity;    &#125;    /**     * 如果map中的数据量大于设定的最大容量，返回true，再新加入对象时删除最旧的数据     *     * @param eldest 最老的数据项     * @return true则移除最老的数据     */    @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;        // 当 map中的数据量大于指定的缓存个数的时候，自动移除最旧的数据        return size() &gt; capacity;    &#125;&#125;\n\n\n\n最后，再看看如何手写一个LRU？其实LeetCode上面就有一道这样的题：LRU 缓存。\nclass LRUCache &#123;    private int capacity;    private DualListNode dummyHead, dummyTail;    private Map&lt;Integer, DualListNode&gt; cache;    public LRUCache(int capacity) &#123;        this.capacity = capacity;        dummyHead = new DualListNode();        dummyTail = new DualListNode();        dummyHead.next = dummyTail;        dummyTail.prev = dummyHead;        cache = new HashMap&lt;&gt;(capacity);    &#125;    public int get(int key) &#123;        DualListNode node = cache.get(key);        if (node == null) &#123;            return -1;        &#125;        // 当前数据作为最近被使用过的，将它在链表中的位置更新至头部        update(node);        return node.val;    &#125;    public void put(int key, int value) &#123;        DualListNode node = cache.get(key);        if (node != null) &#123;            node.val = value;            update(node);            return;        &#125;        // 缓存容量已达上限。需要先删除最久未使用的数据，然后才能插入当前数据        if (cache.size() == capacity) &#123;            cache.remove(pollLast());        &#125;        node = new DualListNode(key, value);        // 当前数据作为最新插入的，直接插在链表头部        offerFirst(node);        cache.put(key, node);    &#125;    private void update(DualListNode node) &#123;        // 第一步：删除该节点在链表中的位置        remove(node);        // 第二步：将该节点添加在头部        offerFirst(node);    &#125;    private void offerFirst(DualListNode node) &#123;        node.prev = dummyHead;        node.next = dummyHead.next;        dummyHead.next.prev = node;        dummyHead.next = node;    &#125;    private void remove(DualListNode node) &#123;        node.prev.next = node.next;        node.next.prev = node.prev;    &#125;    private int pollLast() &#123;        DualListNode node = dummyTail.prev;        remove(node);        return node.key;    &#125;    private static class DualListNode &#123;        private int key, val;        private DualListNode prev, next;        public DualListNode() &#123;&#125;        public DualListNode(int key, int val) &#123;            this.key = key;            this.val = val;        &#125;    &#125;&#125;\n\n\n\nRedis的线程模型？Redis内部使用的是一个叫做 FileEventHandler 的处理器。这个处理器是单线程工作的，所以Redis实质上是一个单线程的模型！\n它采用的是IO多路复用的机制，可以同时监听多个socket，并根据socket上的事件，来选择对应的handler进行处理。\n总得来说，虽然同时会有多个socket，会并发进行不同的操作，但是IO多路复用机制会监听这些socket，并把socket产生的事件放入到队列中进行排队。然后由事件分派器从队列中取出一个个事件，把它交给对应的handler去做处理。\n这个IO多路复用的具体实现思路，在我学习Netty的时候是有所了解的。可以移步至我之前的Netty学习记录：「Netty」网络编程の王！\n\n\nRedis支持的数据结构及其操作命令🔗 CSDN文章\n","tags":["中间件","Redis"]},{"title":"「MySQL」SQL优化总结","url":"/2022/09/15/%E3%80%8CMySQL%E3%80%8D%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%8430%E6%9D%A1%E5%BB%BA%E8%AE%AE/","content":"前言在学习MySQL的索引的时候，总结了一些利用索引等方式来进行SQL查询优化的经验，在这里记录一下。\n首先，本文的所有示例，全部使用一张假定的account表。下面给出它的表结构：\ncreate table account (    `id` int(10) not null primary key,    `username` varchar(255) not null,    `age` int(10) not null,    `sex` tinyint(1) default null,    `create_time` datetime(3) default current_timestamp(3) not null,    key `idx_username` (`username`));\n\n\n\n建议查询SQL，尽量不要使用select *，而是select具体字段名❎ 反例：\nselect *from account;\n\n\n\n✅ 正例：\nselect id, usernamefrom account;\n\n\n\n📄 理由：\n\n需要什么字段，就拿什么字段。节省资源、减少网络开销。\n使用 select * 进行查询时，就无法利用索引覆盖了，造成回表查询。\n\n\n\n查询SQL，如果知道结果只有一条or只需要最大&#x2F;最小的一条，可以加上 limit 1❎ 反例：\nselect idfrom accountwhere username = &#x27;twq&#x27;;\n\n\n\n✅ 正例：\nselect idfrom accountwhere username = &#x27;twq&#x27;limit 1;\n\n\n\n📄 理由：\n\n加上 limit 1 之后，只要找到了一条对应的记录，就不会再继续扫描了。查询效率得到提升。\n\n\n\n尽量避免在where子句中使用 or 来连接条件在account表中，有一个关于username的普通索引。\n假设现在需要查询 username&#x3D;’twq’ 或者 age&#x3D;18 的记录：\n❎ 反例：\nselect *from accountwhere username = &#x27;twq&#x27;   or age = 18;\n\n\n\n✅ 正例：\nselect id, username, age, sex, create_timefrom accountwhere username = &#x27;twq&#x27;union allselect id, username, age, sex, create_timefrom accountwhere age = 18;\n\n\n\n📄 理由：\n\n使用 or 进行条件连接时，可能会使索引失效，从而扫描全表。\n\n\n\n尽量避免在索引字段上使用 !&#x3D; 或 &lt;&gt; 操作符这里假设age字段已经加了索引。\n❎ 反例：\nselect *from accountwhere age != 18;\n\n\n\n✅ 正例：\nselect *from accountwhere age &lt; 18union allselect *from accountwhere age &gt; 18\n\n\n\n📄 理由：\n\n使用 !&#x3D; 或 &lt;&gt; 这样的不等号，那么索引是不会生效的。\n\n\n\n优化limit分页在做分页查询的需求时，一般都是用limit来实现的。但是，当查询的页数非常深，使得limit的偏移量非常大的时候，查询效率就变得很低了。\n这是因为MySQL并非是跳过偏移量直接取后面的数据，而是先把偏移量+要取的条数都查出来，然后在展示时只返回最终要取的这些条数。总结来说就是：得不偿失。\n❎ 反例：\nselect *from accountlimit 10000, 10;\n\n\n\n✅ 正例：\n-- 方案一：手动跳过这些偏移量select id, usernamefrom accountwhere id &gt; 10000limit 10;-- 方案二：order by + 索引select id, usernamefrom accountorder by idlimit 10000, 10;\n\n\n\n📄 理由：\n\n使用方案一，就可以快速跳过这些偏移量，效率得到大幅提升。\n使用方案二，通过对建立了索引的字段进行排序，也可以提升查询效率。\n\n\n\n优化like语句在做分页查询的条件筛选时，经常会有模糊匹配的需求，一般都是用like关键字来实现的。\n但是like很可能会让索引失效。\n❎ 反例：\nselect id, usernamefrom accountwhere username like &#x27;%tang&#x27;;\n\n\n\n✅ 正例：\nselect id, usernamefrom accountwhere username like &#x27;tang%&#x27;;\n\n\n\n📄 理由：\n\n把 % 放在前面，是不会走索引的；把 % 放在后面，是会走索引的。\n\n\n虽然话是这样说，但是。。做模糊匹配，一般都是直接 like ‘%xxx%’ 的吧 &#x3D; &#x3D;\n\n\n\n尽量避免在索引字段上使用MySQL的内置函数假设有个业务需求：需要查询最近7天注册的新用户。此外，假设create_time字段也已经加了索引。\n❎ 反例：\nselect usernamefrom accountwhere date_add(create_time, interval 7 day) &gt;= now();\n\n\n\n✅ 正例：\nselect usernamefrom accountwhere create_time &gt;= date_sub(now(), interval 7 day);\n\n\n\n📄 理由：\n\n在索引列上使用内置函数，那么索引是不会生效的。\n\n\n\n尽量避免在索引字段上进行表达式操作❎ 反例：\nselect *from accountwhere age - 1 = 10;\n\n\n\n✅ 正例：\nselect *from accountwhere age = 10 + 1;\n\n\n\n📄 理由：\n\n在索引列上进行运算等表达式操作，索引也是不会生效的。\n\n\n\n如果一个字段的类型是字符串，在where条件查询时，请不要遗漏引号我们对username字段已经加了索引。但是如果在查询时漏了引号，那么索引是不会生效的！\n❎ 反例：\nselect *from accountwhere username = 1234;\n\n\n\n✅ 正例：\nselect *from accountwhere username = &#x27;1234&#x27;;\n\n\n\n📄 理由：\n\n对于一个字符串类型的字段，如果在where查询时，没有加上引号，那么MySQL会做隐式的类型转换，本来有的索引也失效了。\n\n\n\n使用联合索引时，需要注意索引列的顺序，尽量匹配最左前缀原则\n\n如果需要插入的数据比较多，建议批量插入❎ 反例：\nfor (Account acc : list) &#123;    insert into account(name, age) values(acc.getName(), acc.getAge())&#125;\n\n\n\n✅ 正例：\ninsert into account(name, age) values&lt;foreach collection=&quot;list&quot; item=&quot;acc&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt;    (#&#123;acc.name&#125;, #&#123;acc.age&#125;)&lt;/foreach&gt;\n\n\n\n📄 理由：\n\n在向MySQL服务发送指令时，都是通过网络传输的。而每个连接，都会经历建立时的三次握手、销毁时的四次挥手。\n假设一次性需要插入1000条数据，那么循环1000次单条insert语句，就相当于要建立1000次连接。这样带来的网络连接开销是很大的。\n所以，建议批量插入，性能会更好。\n\n\n\n\n慎用distinct关键字❎ 反例：\nselect distinct *from account;\n\n\n\n✅ 正例：\nselect distinct agefrom account;\n\n\n\n📄 理由：\n\ndistinct关键字一般用于过滤重复记录。但是，如果查询的字段数量很多的情况下，其查询效率会大大降低。因为数据库引擎需要对大量数据的大量字段进行比较、过滤，这个过程比较占用CPU资源。\n所以，*不要无脑使用 ，而是先想想：自己真的需要这么多字段的信息吗？\n\n\n","tags":["MySQL"]},{"title":"「Netty」网络编程の王！","url":"/2022/07/17/%E3%80%8CNetty%E3%80%8D%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%81%AE%E7%8E%8B%EF%BC%81/","content":"前言Netty是一个基于NIO的 c-s（客户端-服务器）框架。它对TCP、UDP套接字服务器编程做了很好的封装，极大的简化了开发流程。使用它可以快速地进行网络应用程序的开发。\n在简化开发流程的同时，其性能和安全性等方面也有很大的保障。并且支持多种协议。因此，很多开源项目都有Netty的身影，比如：Dubbo、RocketMQ、ElasticSearch……经历了如此多的大型项目的使用与考验，可以说，Netty的社区活跃度是很高的，并且质量是较为成熟稳定的！\n\n\nNetty的使用场景理论上来说，所有需要NIO的地方，都可以使用Netty来代替，并且它可以做得比Java官方的NIO有着更好的表现。\n在实际应用中，Netty一般是用于网络通信的：\n\n作为RPC框架的底层网络通信工具：在分布式系统中，如果不同的服务节点之间需要相互调用，那么一定是需要网络通信作为纽带的\n\n实现一个HTTP服务器：作为Java后端开发，一般都是直接使用Tomcat作为HTTP服务器来处理各种请求，如GET&#x2F;POST请求等。当然，有了Netty，我们也可以自己实现一个HTTP服务器\n\n实现一个即时通讯系统：可以通过Netty来实现一个类似微信的即时聊天软件。这个方向的开源项目挺多的，可以在GitHub上找一找。\n\n\n\n\nNetty核心组件Bootstrap &amp; ServerBootstrapBootstrap是客户端的启动引导类，而ServerBootstrap是服务端的启动引导类。\n啥是启动引导类？就是需要通过调用它来启动服务端&#x2F;客户端。\n下面，我分别贴出客户端和服务端的启动代码来感受一下它们在其中的作用与使用方式。\n\n客户端与Bootstrap：\n\npublic static void main(String[] args) &#123;    NioEventLoopGroup group = new NioEventLoopGroup();    try &#123;        // 通过 new Bootstrap() 作为启动等一系列操作的调用者        Channel channel = new Bootstrap()            .group(group)            .channel(NioSocketChannel.class)            .handler(            new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                @Override                protected void initChannel(NioSocketChannel nioSocketChannel) &#123;                    // handler...                &#125;            &#125;)            .connect(&quot;localhost&quot;, &quot;8080&quot;)            .sync()            .channel();        channel.closeFuture().sync();    &#125; catch (InterruptedException e) &#123;        log.info(&quot;客户端出错，原因：&#123;&#125;&quot;, e.getMessage(), e);    &#125; finally &#123;        group.shutdownGracefully();    &#125;&#125;\n\n\n\n\n服务端与ServerBootstrap：\n\npublic static void main(String[] args) &#123;    NioEventLoopGroup boss = new NioEventLoopGroup();    NioEventLoopGroup worker = new NioEventLoopGroup();    try &#123;        Channel channel = new ServerBootstrap()            .group(boss, worker)            .channel(NioServerSocketChannel.class)            .childHandler(            new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                @Override                protected void initChannel(NioSocketChannel nioSocketChannel) &#123;                    // handler...                &#125;            &#125;)            .bind(&quot;8080&quot;)            .sync()            .channel();        channel.closeFuture().sync();    &#125; catch (InterruptedException e) &#123;        log.info(&quot;服务器出错，原因：&#123;&#125;&quot;, e.getMessage(), e);    &#125; finally &#123;        boss.shutdownGracefully();        worker.shutdownGracefully();    &#125;&#125;\n\n\n\n对上面的代码做一些进一步的解释与记录：\n\n\nBootstrap通常使用connect()方法来指定服务端的主机地址以及端口号；如果是一个UDP协议，也可以直接使用bind()方法来指定到本机地址的一个端口号\nServerBootst通常使用bind()方法来绑定到本机的一个端口上，然后只需要等待客户端的连接即可\nBoostrap只需要配置一个线程组EventLoopGroup即可，而ServerBootstrap一般需要两个线程组（Boss和Worker），一个负责接收连接，一个负责处理事件\n\n\n\n\nChannelChannel接口是Netty对于网络操作的一个总抽象，包含了基本的IO操作，如 bind()、connect()、read()、write() 等。\n在Netty自带的67个实现类中，比较常用的两个实现类是 NioSocketChannel（客户端） 和 NioServerSocketChannel（服务端），这两个 Channel 可以分别和BIO编程中的 Socket 和 ServerSocket 相对应上。而Netty提供的这两个实现类，大大降低了直接操作Socket的复杂度。\n\n\nEventLoopEventLoop，也称为事件循环，是Netty的一个核心概念。用官方的话来说，“EventLoop用于处理连接的生命周期中所发生的事件”。\n说白了：**EventLoop的主要作用就是负责监听网络事件，并调用对应的事件处理器来进行IO操作的处理。**每一个EventLoop的内部，通常都包含一个线程。每个EventLoop对于IO的处理，就在它自己专有的那个线程上进行，这样也可以保证线程安全性。\n与前面介绍的 Channel 联系起来，Channel为网络的各种操作（读、写、连接、绑定端口）的抽象类，而EventLoop负责为所有注册的Channel进行IO处理。\n\n\n这里要多提一点，那就是EventLoopGroup。\nEventLoopGroup包含了多个EventLoop。从结构上说，一个EventLoopGroup可分为Boss EventLoopGroup和Worker EventLoopGroup，其中Boss EventLoopGroup用于接收连接，Worker EventLoopGroup用于具体的处理。\n\n\n\n上图是一个 EventLoopGroup 在服务端中的大致使用流程。可以看到：当客户端通过 connect() 连接至服务端时，bossGroup就会处理这些连接请求。当bossGroup处理完毕后，再把这个连接移交给workerGroup来进行具体的处理操作。\n\n\nChannelFuture首先，Netty是异步非阻塞的，这意味着我们无法立刻得到一个执行的结果。\n所以，我们就需要通过ChannelFuture接口的addListener()方法，注册一个ChannelFutureListener。每当操作执行成功&#x2F;失败后，对应的Listener就会自动触发并返回结果。\n翻看ChannelFuture接口的源码，其中有三个比较常用的方法：\npublic interface ChannelFuture extends Future&lt;Void&gt; &#123;    Channel channel();    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; var1);    ChannelFuture sync() throws InterruptedException;        // ....&#125;\n\n\n\n\n\n通过channel()方法来获取关联的Channel对象\n通过sync()方法，使整个操作由异步变为同步\n\n\n\n\nChannelPipeline &amp; ChannelHandlerChannelHandler是请求消息的具体处理器，负责进行读写、客户端连接等操作。\nPipeline的意思是流水线。所以，ChannelPipeline就是关于ChannelHandler的一条流水线，即定义了多个ChannelHandler的调用顺序链。\n具体用法是：在ChannelPipeline上通过addLast()方法，有序地添加一个个ChannelHandler对象（就像操作队列那样）。在这个过程中，其实是一个责任链模式，即：一个ChannelHandler处理完毕后，就将结果移交给下一个ChannelHandler，直至最后一个结束。\n贴个实际代码看一下：\nChannel channel = new Bootstrap()    .group(group)    .channel(NioSocketChannel.class)    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;        @Override        protected void initChannel(NioSocketChannel nioSocketChannel) &#123;            ChannelPipeline pipeline = nioSocketChannel.pipeline();            // 这里的处理器添加顺序是有讲究的！只有确保消息是解析正确的情况下（不存在半包现象），才能进行后续的处理            pipeline.addLast(new ProtocolFrameDecoder());            pipeline.addLast(new MessageCodec());            // 如果 3s 内没有向服务器发送数据，那么就会触发 WRITER_IDLE 事件            pipeline.addLast(new IdleStateHandler(0, 3, 0, TimeUnit.SECONDS));            pipeline.addLast(new IdleEventHandler());        &#125;    &#125;);\n\n\n\nNetty服务器和客户端的启动流程服务端\n创建两个 NioEventLoopGroup 对象：bossGroup和workerGroup。前者负责处理发来的连接请求，后者负责根据每一条连接的具体事件，找到对应的Handler来进行处理\n创建服务端的启动引导类 ServerBootstrap 来辅助服务端的启动工作\n通过 .group() 方法，给引导类配置线程组（步骤1已创建好）\n通过 .channel() 方法，指定IO模型（一般都是指定为 NioServerSocketChannel.class，即NIO模式）\n通过 .childHandler() 方法，给引导类配置一个 ChannelInitializer，用于指定服务端的具体处理逻辑链\n通过 .bind() 方法，将服务绑定到某个端口\n\n客户端\n创建一个 NioEventLoopGroup 对象\n创建客户端的启动引导类 Bootstrap 来辅助客户端的启动工作\n通过 .group() 方法，给引导类配置线程组（步骤1已创建好）\n通过 .channel() 方法，指定IO模型（一般都是指定为 NioSocketChannel.class，即NIO模式）\n通过 .handler() 方法，给引导类配置一个 ChannelInitializer，用于指定服务端的具体处理逻辑链\n通过 .connect() 方法，将服务连接到某个ip地址的某个端口\n\n\n\n关于Netty的零拷贝技术关于百科中对于零拷贝技术的介绍：\n\n零复制（Zero-Copy），也称为零拷贝，是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。\n这种技术通常用于通过网络传输文件时，节省CPU周期和内存带宽。\n\n\n\n在操作系统层面上的零拷贝，指的是避免在 用户态 与 内核态 之间反复拷贝数据。在Netty层面，零拷贝技术主要体现在对于数据操作的优化。\n集中体现在以下方面：\n\n使用Netty提供的CompositeByteBuf类，可以将多个ByteBuf合并为一个逻辑上的ByteBuf，以此避免了不同ByteBuf之间的拷贝切换\nByteBuf支持slice()操作，可以将一个ByteBuf分解为共享同一个内存区域的多个ByteBuf，避免了内存的拷贝\n通过FileRegion包装的FileChannel.transferTo()来实现文件传输，可以直接将文件缓存区的数据发送至目标Channel，以此避免了传统方式下的通过循环write()方法导致的内存拷贝问题\n\n\n\nNetty线程模型Netty主要是依靠 NioEventGroup 线程组的参数配置，来指定具体的线程模型的。\n单线程模式由一个线程组来执行处理所有的事件（accept、read、decode、write、encode、send）。不适用于高负载、高并发的场景。\n对应到具体的实现代码，大概是这样的：\nNioEventLoopGroup group = new NioEventLoopGroup();Channel channel = new Bootstrap()    .group(group)    // something else....\n\n\n\n多线程模式一个 BossGroup 线程组负责监听客户端的连接，一个 WorkerGroup 线程组负责进行具体处理。这样的模式可以满足绝大数的应用场景。\n对应到具体的实现代码，大概是这样的：\nNioEventLoopGroup boss = new NioEventLoopGroup();NioEventLoopGroup worker = new NioEventLoopGroup();Channel channel = new Bootstrap()    .group(boss, worker)    // something else....\n\n\n\n关于TCP粘包&#x2F;半包问题TCP粘包&#x2F;半包现象，就是在基于TCP协议进行数据传输的时候，出现了多个字符串“粘”在一起，或是一个字符串但是被“劈”成两半的现象。\n举个例子，我要发送的字符串是 “Java天下无敌！” ，如果出现了粘包&#x2F;半包问题，那么可能就会变成这样的：\n\n– 粘包（多个字符串合并在一起发送）：\nJava天下无敌！Java天下无敌！Java天下无敌！\n– 半包（一个字符串被拆在两条消息里）：\nJava天下无敌！Java天下无敌！Java天下\n无敌！Java天下无敌！Java天下无敌！\n\n\n\n至于解决办法，我们就需要使用一个关于消息的编解码器。我们可以使用Netty自带的一些编解码器，也可以自定义一个编解码器。\n（占个坑位，🏷️ 未完待续……）\n\n\n关于Netty的长连接、心跳机制根据计算机网络的知识：TCP在进行数据读写之前，必须要先在服务端与客户端之间建立一个连接。这个建立连接与销毁连接的过程，也就是常说的「三次握手，四次挥手」，我之前的文章里也记录过：🔗「计算机网络」TCP的连接建立（期末考试简直是必考&#x3D; &#x3D;）。而这个过程是比较消耗网络资源的。\n短连接说的是，服务端与客户端需要进行一次读写传输，就建立一次连接。操作完毕后就立刻关闭该连接。如果下次还需要进行信息传输，那就再建立一次连接。短连接的优点是：资源管理与代码实现都很简单明了。短连接的缺点是：每次传输都需要建立连接，这个重复的操作会带来大量的网络资源消耗。\n另一种连接模式是长连接。这是指：服务端与客户端在建立了连接以后，即使传输已经完成，它们之间的连接还是不会立刻关闭。这样的好处是：后续的传输可以继续复用这个连接资源，省去不必要的TCP建立与销毁的过程。对于请求较为频繁的场景而言，长连接模式就非常合适。\n如果使用长连接模式，就必须要考虑到断网等网络异常的情况。当异常发生的时候，除非客户端与服务端产生了交互，否则是无法发觉对方已经挂了的。为了能够及时发现对方已经挂了，就需要引入心跳机制。\n心跳机制的工作原理是：如果服务端与客户端之间在一定的时间之内没有产生数据交互，客户端或者服务端就会发生一个特殊的数据包给到对方。当接收方收到这样一个特殊的数据包之后，也立即发送一个特殊的数据包回应发送方，即PING—PONG交互。所以，当某一端收到了这样特殊的数据包之后，就知道对方仍然是在线的。\n\n\n在Netty中，实现心跳机制的核心类是 IdleStateHandler。我们可以在定义 ChannelPipeline 处理链的时候，将这个Handler也一并加入。\nIdleStateHandler 的构造方法共有3个，我们这里选择第二个，分别指定 READER_IDLE 的时间、WRITER_IDLE 的时间、时间单位。\n\n这里的READER_IDLE和WRITER_IDLE时间，指的是：如果在指定时间内没有发生Write事件，那么就会触发一次WRITER_IDLE事件；READER_IDLE事件同理。\n以客户端为例，如果在一定时间内没有向服务器发送数据，那么为了遵循实现心跳机制，我们就应该向服务器发送一次特别的数据。所以，我们的客户端逻辑应该是：当触发了WRITER_IDLE事件时，我们就应该向服务器发送一个心跳数据。\n而我们知道整个处理链是按照添加顺序来的，所以我们应该在这个IdleStateHandler的后面，写上对于WRITER_IDLE事件的Handler。\n\n\n具体的示例代码：\nChannel channel = new Bootstrap()    .group(group)    .channel(NioSocketChannel.class)    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;        @Override        protected void initChannel(NioSocketChannel nioSocketChannel) &#123;            ChannelPipeline pipeline = nioSocketChannel.pipeline();            // something else....            // 如果 3s 内没有向服务器发送数据，那么就会触发 WRITER_IDLE 事件            pipeline.addLast(new IdleStateHandler(0, 3, 0, TimeUnit.SECONDS));            pipeline.addLast(new IdleEventHandler());            // something else....        &#125;    &#125;);\n\n\n\n至于上面的代码里提到的IdleEventHandler，就是负责处理READER_IDLE和WRITER_IDLE事件的处理器。\npublic class IdleEventHandler extends ChannelDuplexHandler &#123;    /**     * 用于触发一些用户的特殊事件     * 在这里，是当 IdleStateHandler 的空闲事件被触发时，会执行该方法     * @param ctx     * @param evt     */    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) &#123;        IdleState state = ((IdleStateEvent) evt).state();        if (state == IdleState.READER_IDLE) &#123;            ctx.channel().close();        &#125; else if (state == IdleState.WRITER_IDLE) &#123;            // 发送一个特别的数据包，作为心跳数据            ctx.writeAndFlush(new PingMessage());        &#125;    &#125;&#125;\n\n","tags":["Java","Netty"]},{"title":"「计算机网络」TCP的连接建立","url":"/2022/05/23/%E3%80%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8DTCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B/","content":"","tags":["计算机网络"]},{"title":"「Java」批量生成SQL语句","url":"/2022/09/28/%E3%80%8CJava%E3%80%8D%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90SQL%E8%AF%AD%E5%8F%A5/","content":"前言最近，上线了一个新的需求，需要对一张旧表进行字段增加，然后向大家收集关于该新增字段的个人信息，最后再汇总起来，执行update的SQL语句。\n由于导出数据时的文件格式就是Excel类型的，所以后续向大家收集信息时，传给大家的也就直接是这个Excel文件，然后大家自己在文件里找到关于自己的那一行，填写好空缺信息。\n在收集完毕以后，问题来了：大约共有100多条数据，我该怎么导入到数据库里去呢？像是Navicat这种工具软件，虽然支持Excel文件导入，但是它只支持insert操作。然而我需要的是update操作！！想了想，好像没找到什么现成的好办法&#x2F;工具。\n这时候，一位同事建议我这么做：先建一张临时表，然后把这个Excel文件的内容全部导入，最后再通过Navicat等数据库工具软件来一键导出sql语句。\n我一开始就这样听信了他的想法，让运维同事帮忙操作一下。几分钟后，运维大哥把导好的SQL文件发给我了。我打开一看，好家伙，这SQL语句看起来有一股“人工智障”的美：\n\n不过我们还是要高情商的，直言道：“厉害！省了我一半工夫了！”😂\n\n\n\n到这里，我开始感觉这个方法行不太通。还是换个思路吧：SQL的本质不就是文本嘛。要不通过Java读取Excel文件，然后直接进行字符串拼接？\n\n\n工具代码首先，为了能够读取Excel文件内容，我们需要引入的一个jar包：org.apache.poi。这是比较流行的一个jar包，很多项目里只要涉及到了Excel文件，就会引入这个依赖。\n另外，这里需要注意一件事：该Excel文件必须是xlsx类型的，否则会运行失败！如果目前还不是，那么可以使用Excel软件自身进行类型转换，通过另存为Excel 工作簿（*.xlsx）的方式保存完毕后，然后再执行工具代码。切记，这里不能直接重命名的方式把后缀名改成.xlsx，否则文件格式还是会有问题！\n其他就没什么多介绍的，直接上代码！！\nimport com.sib.persistence.entity.DevOpsUserStatus;import com.sib.persistence.vo.permission.OmsUserVO;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.*;import java.util.*；public class GenerateSql &#123;    private static final String EXCEL_PATH = &quot;E:\\\\Download\\\\01.xlsx&quot;;    private static final String OUTPUT_PATH = &quot;E:\\\\Download\\\\01.sql&quot;;    private static final String NEW_LINE = System.getProperty(&quot;line.separator&quot;);    private static final Writer WRITER;    private static final Map&lt;String, String&gt; EMPTY_VALUE_MAP;    static &#123;        // 如果文件已存在，那么先删除原文件        File file = new File(OUTPUT_PATH);        if (file.exists()) &#123;            file.delete();        &#125;        // 创建writer（第二个参数指定为true，代表当前模式是追加写入而不是覆盖写入）        try &#123;            WRITER = new BufferedWriter(new FileWriter(OUTPUT_PATH, true));        &#125; catch (IOException e) &#123;            e.printStackTrace();            throw new RuntimeException(e);        &#125;        // 值为空时的表示形式（取决于数据库表的具体设计，该字段是否允许存储null？）        EMPTY_VALUE_MAP = new HashMap&lt;String, String&gt;() &#123;&#123;            put(&quot;scopes&quot;, &quot;null&quot;);            put(&quot;chinese_name&quot;, &quot;&#x27;&#x27;&quot;);        &#125;&#125;;    &#125;    public static void main(String[] args) &#123;        List&lt;UserVO&gt; list = readFromExcel(EXCEL_PATH);        System.out.println(&quot;readFromExcel, size is : &quot; + list.size());        for (UserVO user : list) &#123;            doGenerate(user);        &#125;    &#125;    private static List&lt;UserVO&gt; readFromExcel(String excelPath) &#123;        try (XSSFWorkbook sheets = new XSSFWorkbook(excelPath)) &#123;            List&lt;UserVO&gt; list = new ArrayList&lt;&gt;();            XSSFSheet sheet = sheets.getSheetAt(0);            for (int i = 1; i &lt; sheet.getPhysicalNumberOfRows(); i++) &#123;                UserVO user = new UserVO();                enrichEntity(user, sheet.getRow(i));                list.add(user);            &#125;            return list;        &#125; catch (IOException e) &#123;            e.printStackTrace();            throw new RuntimeException(e);        &#125;    &#125;    private static void doGenerate(UserVO user) &#123;        try &#123;            WRITER.append(&quot;update tb_user set &quot;)                    .append(&quot;scopes = &quot;)                    .append(isEmptyString(user.getScopes()) ? EMPTY_VALUE_MAP.get(&quot;scopes&quot;) : &quot;&#x27;&quot; + user.getScopes() + &quot;&#x27;&quot;)                    .append(&quot;, chinese_name = &quot;)                    .append(isEmptyString(user.getEnglishName()) ? EMPTY_VALUE_MAP.get(&quot;chinese_name&quot;) : &quot;&#x27;&quot; + user.getEnglishName() + &quot;&#x27;&quot;)                    .append(&quot; where username = &#x27;&quot;)                    .append(user.getUsername())                    .append(&quot;&#x27;;&quot;)                    .append(NEW_LINE);            WRITER.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();            throw new RuntimeException(e);        &#125;    &#125;    private static void enrichEntity(UserVO user, XSSFRow row) &#123;        String username = null;        String scopes = &quot;&quot;;        String chineseName = &quot;&quot;;        XSSFCell usernameCell = row.getCell(1);        XSSFCell scopesCell = row.getCell(2);        XSSFCell chineseNameCell = row.getCell(3);        if (usernameCell != null) &#123;            usernameCell.setCellType(CellType.STRING);            username = usernameCell.getStringCellValue();        &#125;        if (scopesCell != null) &#123;            scopesCell.setCellType(CellType.STRING);            scopes = scopesCell.getStringCellValue();        &#125;        if (chineseNameCell != null) &#123;            chineseNameCell.setCellType(CellType.STRING);            chineseName = chineseNameCell.getStringCellValue();        &#125;        user.setUsername(username);        user.setScopes(scopes);        user.setchineseName(chineseName);    &#125;    private static boolean isEmptyString(String str) &#123;        return str == null || str.length() == 0;    &#125;&#125;\n\n","tags":["Java","实习经历","工具方法"]},{"title":"「设计模式」策略模式的实际应用场景","url":"/2022/09/25/%E3%80%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","content":"前言最近在实习工作的过程中，发现整个项目里有些地方运用到了设计模式的代码思路，读着觉得十分精妙。我在学习编程的路上，当然也学过、听闻过很多设计精巧的模式。但是一切都只停留在理论层面，或只是肤浅的小入门demo。结合到自身项目，总感觉不知道该如何下手。\n所以这也是实习的一大收获吧！可以接触到规模较大、已上线使用的项目，并学习里面很多前辈同事的编码精妙之处。\n今天就来记录一下，我所发现的一些设计模式之策略模式，在实际项目中的实现思路。（由于需要保护公司的机密隐私，所以一切代码内容都是临时编造的。主要看的是思路和结构~）\n\n\n场景一我们的项目里有一个场景，就是对于一些事情，可以以发送消息给消息队列的形式，来触发一个task，执行需要做的事情。通过这种异步+MQ的方式，提升整个系统的吞吐量。\n比如：我们更换了服务代理商，现在需要通知广大用户这个新的服务代理商与新规则，所以就需要给每个用户发送邮件来进行提醒；我们更新了某个用户文件的样式，现在需要进行同步，所以就需要给每个用户重新生成一次这个文件……\n可以将上述提到的每件事情，作为一个个task进行执行。在调用时，只需要约定好destination地址，然后由postman来发送一个消息请求给到消息队列，就可以执行指定的task任务了。\n不同的task虽然业务逻辑各不相同，但是总体的流程其实是一样的：先根据条件来查询并拉取数据（produce），然后根据业务流程来对每条数据进行具体处理（consume）。\n因此，我们可以创建一个抽象类，并定义好总体流程，然后让所有的task都继承这个抽象类，并重写各自的produce和consume方法即可。\n另外，既然是task，那么我们就实现一下Runnable接口吧，把总体流程直接写在run()方法里。\npublic abstract class AbsProducerConsumer&lt;T&gt; implements Runnable &#123;    private static final Logger logger = LoggerFactory.getLogger(AbsProducerConsumer.class);    private ExecutorService executorService = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workerQueue, new ThreadPoolExecutor.CallerRunsPolicy());    private ArrayBlockingQueue&lt;T&gt; pipeline = new ArrayBlockingQueue&lt;&gt;();        public void run() &#123;        try &#123;            long startTime = System.currentTimeMillis();            executorService.submit(() -&gt; &#123;                // producer                while (true) &#123;                    List&lt;T&gt; products = produce();                    if (!CollectionUtils.isEmpty(products)) &#123;                        logger.info(&quot;trying to put &#123;&#125; products into pipeline&quot;, products.size());                        products.forEach(product -&gt; &#123;                            try &#123;                                pipeline.put(product);                            &#125; catch (InterruptedException e) &#123;                                logger.error(&quot;skip product [&#123;&#125;] due to &#123;&#125;, failed to put into pipeline: &#123;&#125;&quot;, product.getClass().getSimpleName(), e.getMessage(), JsonUtil.getJSON(product), e);                            &#125;                        &#125;);                    &#125;                    if (CollectionUtils.isEmpty(products) || isProduceAllInOneTime()) &#123;                        logger.info(&quot;producer is finished since there is no products any more&quot;);                        try &#123;                            logger.info(&quot;putting a poison in pipeline in order to shutdown&quot;);                            pipeline.put(producePoisonPill());                        &#125; catch (InterruptedException ignore) &#123;&#125;                        break;                    &#125;                &#125;                logger.info(&quot;producer finished&quot;);            &#125;);            // consumer            while (true) &#123;                T product = pipeline.take();                if (!isPoisonPill(product)) &#123;                    executorService.submit(() -&gt; &#123;                        try &#123;                            consume(product);                        &#125; catch (Exception e) &#123;                            logger.error(&quot;&#123;&#125; skip due to &#123;&#125;, failed to take out pipeline: &#123;&#125;&quot;, getConcreteClassName(), e.getMessage(), JsonUtil.getJSON(product), e);                        &#125;                    &#125;);                &#125; else &#123;                    logger.info(&quot;get a poison pill, trying to shut down&quot;);                    executorService.shutdown();                    executorService.awaitTermination(1, TimeUnit.DAYS);                    long endTime = System.currentTimeMillis();                    logger.info(&quot;finished in &#123;&#125; minutes, start at &#123;&#125; and end at &#123;&#125;&quot;, (endTime - startTime) / 1000 / 60, startTime, endTime);                    break;                &#125;            &#125;        &#125; catch (Exception e) &#123;            logger.error(&quot;&#123;&#125; failed due to: &#123;&#125;&quot;, getConcreteClassName(), e.getMessage(), e);            throw new RuntimeException(e);        &#125;    &#125;        public abstract List&lt;T&gt; produce();        public abstract void consume(T product);        public abstract T producePoisonPill();        public abstract boolean isPoisonPill(T product);&#125;\n\n\n\n这里需要说明几点：\n\n\nproducePoisonPill() 是用于传达一个「结束信号」，比如全部拉取结束了之后，在最后放入一个特殊的product作为「结束信号」。一般放入null\nisPoisonPill() 是用于判断当前的product是否就是那个「结束信号」。如果是，那么可以认为已经全部消费完毕了\n\n\n\n\n在消息的接收端，也有策略模式的体现之处。\n示例代码：\n@Componentpublic class TaskConsumer &#123;    @Autowired    private BeanFactory beanFactory;        @JmsListener(destination = &quot;queue.xxxx.xxxx&quot;, containerFactory = &quot;ContainerFactory&quot;)    public void consumer1(String msgType) &#123;        try &#123;            Consumer1 consumer = beanFactory.getBean(Consumer1.class);            consumer.setMsgType(msgType);            new Thread(consumer).start();        &#125; catch (Exception e) &#123;            logger.error(&quot;Consumer1 finished, Exception has occurred, failed due to: &#123;&#125;&quot;, e.getMessage(), e);            throw new RuntimeException(e);        &#125;    &#125;        @JmsListener(destination = &quot;queue.yyyy.yyyy&quot;, containerFactory = &quot;ContainerFactory&quot;)    public void consumer2(String msgType) &#123;        try &#123;            Consumer2 consumer = beanFactory.getBean(Consumer2.class);            consumer.setMsgType(msgType);            new Thread(consumer).start();        &#125; catch (Exception e) &#123;            logger.error(&quot;Consumer2 finished, Exception has occurred, failed due to: &#123;&#125;&quot;, e.getMessage(), e);            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n\n\n不同的task类，总结而言都是调用 run() 方法来执行任务（只是任务的内容各不相同）。于是我们可以通过 BeanFactory 的 getBean() 方法，来指定对应的Task类，从而获取到对象。\n\n\n场景二","tags":["项目","实习经历","设计模式"]},{"title":"「Redis」关于缓存雪崩、穿透、击穿问题","url":"/2022/09/13/%E3%80%8CRedis%E3%80%8D%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/","content":"缓存雪崩(Cache Avalanche)定义缓存机器意外发生了全盘宕机，于是之后的很多请求就直接落到了数据库上，造成数据库在短时间内承受了超量的请求，服务宕机。\n\n\n解决方案\n事前：部署主从+哨兵的集群模式，避免全盘崩溃\n\n事中：进行请求限流，避免MySQL宕机。\n限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，可以友情提示，或者返回空值。\n\n事后：Redis持久化。重启后自动从磁盘上加载数据，快速恢复缓存数据\n\n\n\n\n缓存穿透(Cache Penetration)定义大量请求要查询的key并不存在于缓存中。于是，这些请求就直接落到了数据库上，造成数据库在短时间内承受了大量的请求，服务宕机。\n\n\n解决方案\n缓存这些无效的key：\n如果一个key，在缓存和数据库中都无法查到，那么就可以认为它是一个无效的key。可以将这样的key都记录在Redis中，下次再有同样的无效key，就可以直接返回了。\n但是，这种方式只能解决key变化不频繁的情况。如果有黑客进行恶意攻击，每次构建都是不同的请求key，会导致Redis中存储了太多的无效key。所以，这种方案并不能从根本上解决问题。\n如果选择此方案，最好将缓存的无效key的过期时间设置得短一些，比如1分钟。\n如果用Java代码来进行上述实现，大概是这样的：\npublic Object getValueByKey(String key) &#123;    Object value = getFromCache(key);    if (value == null) &#123;        value = getFromDatabase(key);        setToCache(key, value);        if (value == null) &#123;            expireCache(key, 60);        &#125;    &#125;    return value;&#125;\n\n\n\n使用布隆过滤器来判断key是否是无效的：\n布隆过滤器是一个神奇的数据结构，通过它，可以非常方便地判断一个给定的数据是否存在于一个海量的数据集之中。\n所以，在解决缓存穿透问题这个情景之下，我们需要做的就是：首先，把所有可能存在的有效key都存放在这个布隆过滤器之中。当用户发起一个请求时，就直接判断这个key是否存在于布隆过滤器中（换言之，就是在判断这个key是否有效）？如果不存在，那么就可以直接返回请求错误的信息给客户端了。\n从网上找了一张图，我感觉总结得挺好的：\n\n\n\n关于布隆过滤器：\n\n布隆过滤器的本质是「位(bit)数组」，也就是说每一个存入布隆过滤器的数据都只占一位，空间占用非常小。\n但是如此带来的缺点是：返回的结果有时并不够精准。布隆过滤器说某个元素存在，并不一定真的存在；布隆过滤器说某个元素不存在，那就一定真的不存在。\n当一个元素加入到布隆过滤器的时候，是这样做的：调用布隆过滤器中的哈希函数，计算得到新增元素的哈希值，然后在bit数组中，把对应的下标处记为1。（在这个过程中，会有多个哈希函数，计算得到多个哈希值，并把这些位置都记为1）\n当判断一个元素是否存在于布隆过滤器的时候，是这样做的：调用布隆过滤器中的哈希函数，计算得到目标元素的哈希值（也是有多个），然后在bit数组中，判断这些对应的位置的值是否已经为1。如果都是1，说明这个元素已经存在于布隆过滤器中了；否则，就认为这个元素不存在。\n既然布隆过滤器的原理是通过哈希函数+bit数组，而只要涉及哈希，就不可避免会存在哈希冲突的问题。所以说，回到开头时的结论：布隆过滤器说某个元素存在，并不一定真的存在。现在想想应该就能明白了。\n\n\n\n\n\n缓存击穿(Hotspot Invalid)定义某些 key 大面积同时失效，大量的请求就击穿了缓存，直接请求到了数据库，就像是在一道屏障上凿开了一个大洞。\n\n\n解决方案可以在设置每个key的失效时间的时候，将这个失效时间设为随机的（在1~5分钟之内）。这样一来，就很难出现「大量缓存同时失效」的情况了。\n","tags":["中间件","Redis"]}]